<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hot100-10</title>
    <link href="/2024/08/07/hot100-10/"/>
    <url>/2024/08/07/hot100-10/</url>
    
    <content type="html"><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">https://leetcode.cn/problems/binary-tree-inorder-traversal/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树的根节点 <code>root</code>，返回它的中序遍历。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>中序遍历的顺序是左子树 -&gt; 根节点 -&gt; 右子树。我们可以使用递归和迭代两种方法来实现中序遍历。</p><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><ol><li>初始化一个列表 <code>list</code> 用于存储遍历结果。</li><li>定义一个辅助函数 <code>inorder</code>，接受当前节点 <code>root</code> 和结果列表 <code>list</code> 作为参数。</li><li>在辅助函数中，如果当前节点 <code>root</code> 为空，则直接返回。</li><li>递归调用 <code>inorder</code> 函数遍历左子树。</li><li>将当前节点的值添加到结果列表 <code>list</code> 中。</li><li>递归调用 <code>inorder</code> 函数遍历右子树。</li><li>返回结果列表 <code>list</code>。</li></ol><h3 id="递归代码实现"><a href="#递归代码实现" class="headerlink" title="递归代码实现"></a>递归代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        inorder(list, root);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorder(list, root.left);<br>        list.add(root.val);<br>        inorder(list, root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ol><li>使用一个栈 <code>stack</code> 来辅助遍历。</li><li>初始化一个指针 <code>curr</code> 指向根节点 <code>root</code>。</li><li>循环以下操作直到 <code>curr</code> 为空且 <code>stack</code> 为空：<ul><li>将当前节点 <code>curr</code> 的所有左子节点依次入栈，并将 <code>curr</code> 指向其左子节点。</li><li>如果 <code>curr</code> 为空，从栈中弹出一个节点，将该节点的值添加到结果列表 <code>list</code> 中，并将 <code>curr</code> 指向该节点的右子节点。</li></ul></li><li>返回结果列表 <code>list</code>。</li></ol><h3 id="迭代代码实现"><a href="#迭代代码实现" class="headerlink" title="迭代代码实现"></a>迭代代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> root;<br><br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-comment">// 将当前节点的所有左子节点入栈</span><br>            <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(curr);<br>                curr = curr.left;<br>            &#125;<br>            <span class="hljs-comment">// 弹出栈顶节点，并将其值添加到结果列表中</span><br>            curr = stack.pop();<br>            list.add(curr.val);<br>            <span class="hljs-comment">// 转向右子树</span><br>            curr = curr.right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是二叉树的节点数。每个节点都被访问一次。</li><li><strong>空间复杂度</strong>:<ul><li>递归方法：O(h)，其中 <code>h</code> 是树的高度。递归调用栈的深度等于树的高度。</li><li>迭代方法：O(h)，其中 <code>h</code> 是树的高度。栈的最大深度等于树的高度。</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在递归方法中，注意在访问节点时先递归遍历左子树，再处理当前节点，最后递归遍历右子树。</li><li>在迭代方法中，注意使用栈来模拟递归过程，确保正确的遍历顺序。</li></ul><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h1><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">https://leetcode.cn/problems/unique-binary-search-trees/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数 <code>n</code>，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的二叉搜索树有多少种？返回满足题意的二叉搜索树的种数。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。设 <code>dp[i]</code> 表示 <code>i</code> 个节点组成的二叉搜索树的种数。对于一个二叉搜索树，其根节点可以是 <code>1</code> 到 <code>i</code> 中的任意一个节点。假设以 <code>j</code> 为根节点，那么左子树的节点个数为 <code>j-1</code>，右子树的节点个数为 <code>i-j</code>。</p><p>状态转移方程为：<br>[ dp[i] &#x3D; \sum_{j&#x3D;1}^{i} dp[j-1] \times dp[i-j] ]</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化动态规划数组 <code>dp</code>，大小为 <code>n+1</code>，其中 <code>dp[0] = 1</code>，表示空树的种数为 1。</li><li>遍历从 <code>1</code> 到 <code>n</code> 的每个节点数 <code>i</code>，对于每个 <code>i</code>：<ul><li>遍历从 <code>1</code> 到 <code>i</code> 的每个根节点 <code>j</code>，计算左子树和右子树的种数，并累加到 <code>dp[i]</code> 中。</li></ul></li><li>最后返回 <code>dp[n]</code> 作为结果。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 动态规划数组</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 计算每个节点数 i 的二叉搜索树种数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n^2)，其中 <code>n</code> 是节点的个数。我们需要填充 <code>dp</code> 数组，其中每个 <code>dp[i]</code> 需要进行 <code>i</code> 次累加计算。</li><li><strong>空间复杂度</strong>: O(n)，用于存储动态规划数组 <code>dp</code>。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>动态规划数组 <code>dp</code> 的初始化非常重要，特别是 <code>dp[0] = 1</code>，表示空树的种数为 1。</li><li>状态转移方程的推导需要理解二叉搜索树的性质，即每个节点作为根节点时，左子树和右子树的节点数是确定的。</li><li>确保在代码实现中，正确处理数组索引和边界条件。</li></ul><h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">https://leetcode.cn/problems/validate-binary-search-tree/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p>有效二叉搜索树定义如下：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以通过中序遍历来验证二叉搜索树的有效性。中序遍历二叉搜索树时，节点的值应该是严格递增的。因此，我们可以通过中序遍历判断每个节点的值是否满足条件。</p><p>具体步骤如下：</p><ol><li>初始化一个 <code>TreeNode</code> 变量 <code>pre</code>，用于存储中序遍历过程中上一个节点的值。</li><li>定义一个辅助函数 <code>inorder</code>，接受当前节点 <code>root</code> 作为参数。</li><li>在 <code>inorder</code> 函数中：<ul><li>如果当前节点 <code>root</code> 为空，返回 <code>true</code>。</li><li>递归调用 <code>inorder</code> 函数遍历左子树，如果左子树不是有效的二叉搜索树，返回 <code>false</code>。</li><li>如果当前节点的值小于等于 <code>pre</code> 节点的值，返回 <code>false</code>。</li><li>更新 <code>pre</code> 为当前节点。</li><li>递归调用 <code>inorder</code> 函数遍历右子树，并返回结果。</li></ul></li><li>返回中序遍历结果。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    TreeNode pre;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> inorder(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-keyword">if</span> (!inorder(root.left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 检查当前节点是否满足二叉搜索树的条件</span><br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.val &gt;= root.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 更新 pre 为当前节点</span><br>        pre = root;<br><br>        <span class="hljs-comment">// 递归遍历右子树</span><br>        <span class="hljs-keyword">return</span> inorder(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是二叉树的节点数。每个节点都被访问一次。</li><li><strong>空间复杂度</strong>: O(h)，其中 <code>h</code> 是二叉树的高度。递归调用栈的深度等于树的高度。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>中序遍历时，确保每个节点的值严格递增，才能判断为有效的二叉搜索树。</li><li>辅助函数 <code>inorder</code> 的递归调用需要检查左子树和右子树是否满足二叉搜索树的条件。</li><li>初始化 <code>pre</code> 变量为 <code>null</code>，在中序遍历过程中更新 <code>pre</code> 为上一个节点。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-9</title>
    <link href="/2024/08/06/hot100-9/"/>
    <url>/2024/08/06/hot100-9/</url>
    
    <content type="html"><![CDATA[<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h1><p><a href="https://leetcode.cn/problems/subsets/description/">https://leetcode.cn/problems/subsets/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code>，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。你可以按任意顺序返回解集。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来生成所有可能的子集。回溯算法可以动态地构建子集，并在每个递归步骤中决定是否包含当前元素，从而生成所有可能的组合。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化结果列表 <code>list</code> 和路径列表 <code>path</code>。</li><li>定义一个回溯函数 <code>backtracking</code>，它接受一个起始索引 <code>startIndex</code> 和数组 <code>nums</code> 作为参数。</li><li>在每个递归步骤中，将当前路径列表 <code>path</code> 添加到结果列表 <code>list</code> 中。</li><li>遍历数组 <code>nums</code>，从起始索引 <code>startIndex</code> 开始，对于每个元素：<ul><li>将当前元素添加到路径列表 <code>path</code> 中。</li><li>递归调用 <code>backtracking</code>，传递下一个起始索引 <code>i + 1</code>。</li><li>递归返回后，从路径列表 <code>path</code> 中移除最后一个元素，以便于继续生成其他子集。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; list;<br>    List&lt;Integer&gt; path;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtracking(<span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 将当前路径添加到结果列表中</span><br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br><br>        <span class="hljs-comment">// 遍历数组，从起始索引开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 添加当前元素到路径列表</span><br>            path.add(nums[i]);<br>            <span class="hljs-comment">// 递归调用，传递下一个起始索引</span><br>            backtracking(i + <span class="hljs-number">1</span>, nums);<br>            <span class="hljs-comment">// 从路径列表中移除最后一个元素</span><br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n * 2^n)，其中 <code>n</code> 是数组 <code>nums</code> 的长度。每个元素有两种选择（包含或不包含），共有 <code>2^n</code> 个子集，每个子集的平均长度为 <code>n/2</code>。</li><li><strong>空间复杂度</strong>: O(n)，用于存储递归调用栈和路径列表 <code>path</code>。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>回溯算法的核心在于递归地构建子集，并在每个递归步骤中决定是否包含当前元素。</li><li>确保在每次递归调用后，从路径列表 <code>path</code> 中移除最后一个元素，以便于继续生成其他子集。</li><li>将当前路径列表 <code>path</code> 添加到结果列表 <code>list</code> 中时，注意创建 <code>path</code> 的副本，以避免后续修改影响结果。</li></ul><h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h1><p><a href="https://leetcode.cn/problems/word-search/description/">https://leetcode.cn/problems/word-search/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 <code>m x n</code> 的二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code>。如果 <code>word</code> 存在于网格中，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用深度优先搜索（DFS）来解决这个问题。具体步骤如下：</p><ol><li>初始化一个二维布尔数组 <code>flag</code> 来记录每个单元格是否已被使用。</li><li>遍历网格中的每个单元格作为起始点，如果当前单元格的字符与 <code>word</code> 的第一个字符匹配，则调用 DFS 函数进行搜索。</li><li>在 DFS 函数中：<ul><li>如果当前匹配的字符数 <code>n</code> 等于 <code>word</code> 的长度，说明找到完整匹配，返回 <code>true</code>。</li><li>遍历四个方向的相邻单元格，如果相邻单元格的字符与 <code>word</code> 的下一个字符匹配，且该单元格未被使用，则继续递归搜索。</li><li>如果找到匹配，返回 <code>true</code>，否则将该单元格标记为未使用，继续搜索其他方向。</li></ul></li><li>如果遍历完所有单元格都未找到匹配，返回 <code>false</code>。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] dir = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 用于表示四个方向的移动</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br><br>        <span class="hljs-comment">// 遍历每个单元格作为起始点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == word.charAt(<span class="hljs-number">0</span>)) &#123; <span class="hljs-comment">// 如果当前字符匹配 word 的第一个字符</span><br>                    flag[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (dfs(board, <span class="hljs-number">1</span>, word, i, j, flag)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    flag[i][j] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 回溯</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> n, String word, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">boolean</span>[][] flag)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == word.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 完全匹配</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i += <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 遍历四个方向</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextX</span> <span class="hljs-operator">=</span> dir[i] + x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextY</span> <span class="hljs-operator">=</span> dir[i + <span class="hljs-number">1</span>] + y;<br>            <span class="hljs-keyword">if</span> (nextX &lt; <span class="hljs-number">0</span> || nextX &gt;= board.length || nextY &lt; <span class="hljs-number">0</span> || nextY &gt;= board[<span class="hljs-number">0</span>].length || flag[nextX][nextY] || word.charAt(n) != board[nextX][nextY]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            flag[nextX][nextY] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (dfs(board, n + <span class="hljs-number">1</span>, word, nextX, nextY, flag)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            flag[nextX][nextY] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m * n * 4^l)，其中 <code>m</code> 和 <code>n</code> 分别是网格的行数和列数，<code>l</code> 是字符串 <code>word</code> 的长度。最坏情况下，每个单元格都要进行一次深度优先搜索，每次搜索最多有 4 个方向。</li><li><strong>空间复杂度</strong>: O(m * n)，用于存储布尔数组 <code>flag</code> 和递归调用栈。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>递归函数中通过遍历四个方向来进行搜索，每次搜索前标记当前单元格为已使用，搜索结束后回溯。</li><li>如果找到匹配，立即返回 <code>true</code>，否则继续搜索其他方向。</li><li>如果遍历完所有单元格都未找到匹配，返回 <code>false</code>。</li></ul><h1 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h1><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">https://leetcode.cn/problems/largest-rectangle-in-histogram/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 <code>n</code> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code>。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用单调栈来解决这个问题。单调栈可以帮助我们快速找到每个柱子左右两边第一个小于当前高度的柱子，从而确定当前柱子的最大矩形面积。</p><p>具体步骤如下：</p><ol><li>创建一个新的数组 <code>tmp</code>，在 <code>heights</code> 数组的左右各添加一个高度为 <code>0</code> 的哨兵，确保所有柱子都能被处理到。</li><li>使用单调栈 <code>dq</code> 来存储柱子的索引，保持栈内元素递增。</li><li>遍历 <code>tmp</code> 数组：<ul><li>如果当前柱子的高度小于栈顶柱子的高度，说明找到了一个以栈顶柱子为高的矩形区域，计算其面积，并更新最大面积。</li><li>将当前柱子的索引压入栈中。</li></ul></li><li>遍历结束后，返回最大面积。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-comment">// 创建一个新的数组，左右各添加一个高度为 0 的哨兵</span><br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[heights.length + <span class="hljs-number">2</span>];<br>        System.arraycopy(heights, <span class="hljs-number">0</span>, tmp, <span class="hljs-number">1</span>, heights.length);<br>        <br>        <span class="hljs-comment">// 单调栈，保持递增</span><br>        Deque&lt;Integer&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 遍历新数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tmp.length; i++) &#123;<br>            <span class="hljs-comment">// 当前值小于栈顶值，找到一个以栈顶柱子为高的矩形区域</span><br>            <span class="hljs-keyword">while</span> (!dq.isEmpty() &amp;&amp; tmp[i] &lt; tmp[dq.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> tmp[dq.pop()];<br>                result = Math.max(result, (i - dq.peek() - <span class="hljs-number">1</span>) * h);<br>            &#125;<br>            <span class="hljs-comment">// 将当前索引压入栈中</span><br>            dq.push(i);<br>        &#125;        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是柱子的数量。我们只需遍历数组一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储新的数组和单调栈。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用哨兵元素可以简化边界条件的处理，确保所有柱子都能被处理到。</li><li>单调栈用于存储柱子的索引，保持栈内元素递增，以便于快速找到每个柱子左右两边第一个小于当前高度的柱子。</li><li>在计算矩形面积时，需要注意矩形的宽度为当前索引 <code>i</code> 减去栈顶索引减 1。</li></ul><h3 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h3><ol><li>初始化带哨兵的数组 <code>tmp</code> 和单调栈 <code>dq</code>。</li><li>遍历 <code>tmp</code> 数组，使用单调栈记录柱子的索引，确保栈内元素递增。</li><li>当当前柱子的高度小于栈顶柱子的高度时，计算以栈顶柱子为高的矩形区域的面积，并更新最大面积。</li><li>遍历结束后，返回最大面积。</li></ol><h1 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a>85. 最大矩形</h1><p><a href="https://leetcode.cn/problems/maximal-rectangle/description/">https://leetcode.cn/problems/maximal-rectangle/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个仅包含 0 和 1、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以将问题转化为多个柱状图中最大矩形面积的问题。具体来说，将矩阵的每一行看作是一个底，将每一列的高度看作是连续的 1 的数量。对于每一行，我们计算其对应的高度，然后使用单调栈来计算最大矩形面积。</p><p>步骤如下：</p><ol><li>初始化一个高度数组 <code>tmp</code>，其长度为 <code>cols + 2</code>，并在左右各添加一个哨兵。</li><li>遍历矩阵的每一行，更新高度数组 <code>tmp</code>：<ul><li>如果当前元素为 ‘0’，则将对应高度置为 0。</li><li>如果当前元素为 ‘1’，则将对应高度加 1。</li></ul></li><li>对每一行更新后的高度数组 <code>tmp</code>，使用单调栈计算最大矩形面积：<ul><li>使用单调栈存储柱状图的索引，保持栈内元素递增。</li><li>如果当前高度小于栈顶元素高度，则计算以栈顶元素为高的矩形面积，并更新最大面积。</li></ul></li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalRectangle</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[matrix[<span class="hljs-number">0</span>].length + <span class="hljs-number">2</span>]; <span class="hljs-comment">// 高度数组，左右各添加一个哨兵</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; matrix[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-comment">// 更新高度数组</span><br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                    tmp[j + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tmp[j + <span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 使用单调栈计算最大矩形面积</span><br>            Deque&lt;Integer&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; tmp.length; j++) &#123;<br>                <span class="hljs-keyword">while</span> (!dq.isEmpty() &amp;&amp; tmp[dq.peek()] &gt; tmp[j]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> tmp[dq.pop()];<br>                    result = Math.max(result, (j - dq.peek() - <span class="hljs-number">1</span>) * h);<br>                &#125;<br>                dq.push(j);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(rows * cols)，其中 <code>rows</code> 和 <code>cols</code> 分别是矩阵的行数和列数。我们需要遍历每一行，每行遍历的时间复杂度为 O(cols)。</li><li><strong>空间复杂度</strong>: O(cols)，用于存储高度数组 <code>tmp</code> 和单调栈。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>高度数组 <code>tmp</code> 的长度为 <code>cols + 2</code>，并在左右各添加一个哨兵，确保所有柱子都能被处理到。</li><li>在更新高度数组时，如果当前元素为 ‘0’，高度置为 0；如果为 ‘1’，高度加 1。</li><li>使用单调栈来计算最大矩形面积，确保栈内元素递增，以便于快速找到左右边界。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-8</title>
    <link href="/2024/08/05/hot100-8/"/>
    <url>/2024/08/05/hot100-8/</url>
    
    <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h1><p><a href="https://leetcode.cn/problems/climbing-stairs/description/">https://leetcode.cn/problems/climbing-stairs/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。问有多少种不同的方法可以爬到楼顶？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。设 <code>dp[i]</code> 表示爬到第 <code>i</code> 阶的方法数。由于每次只能爬 <code>1</code> 或 <code>2</code> 个台阶，爬到第 <code>i</code> 阶的方法数可以由以下两部分组成：</p><ol><li>从第 <code>i-1</code> 阶爬 <code>1</code> 个台阶到达第 <code>i</code> 阶。</li><li>从第 <code>i-2</code> 阶爬 <code>2</code> 个台阶到达第 <code>i</code> 阶。</li></ol><p>因此，状态转移方程为：<br>[ dp[i] &#x3D; dp[i-1] + dp[i-2] ]</p><p>初始条件为：</p><ul><li>爬到第 <code>0</code> 阶的方法数为 <code>1</code>（不动）。</li><li>爬到第 <code>1</code> 阶的方法数为 <code>1</code>（一步）。</li></ul><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个大小为 <code>n+1</code> 的数组 <code>dp</code>，其中 <code>dp[i]</code> 表示爬到第 <code>i</code> 阶的方法数。</li><li>设置初始条件：<code>dp[0] = 1</code>，<code>dp[1] = 1</code>。</li><li>遍历从 <code>2</code> 到 <code>n</code> 的每个阶梯，计算 <code>dp[i]</code>：<ul><li><code>dp[i] = dp[i-1] + dp[i-2]</code></li></ul></li><li>返回 <code>dp[n]</code> 作为结果。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n; <br>        <span class="hljs-comment">// 动态规划数组，dp[i] 表示爬到第 i 阶的方法数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 计算 dp 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是阶梯的总数。我们需要遍历每个阶梯一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储动态规划数组 <code>dp</code>。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>初始条件 <code>dp[0] = 1</code> 和 <code>dp[1] = 1</code> 是基础，表示从地面到第 <code>1</code> 阶的方法数。</li><li>状态转移方程 <code>dp[i] = dp[i-1] + dp[i-2]</code> 表示每次可以选择爬 <code>1</code> 阶或 <code>2</code> 阶到达第 <code>i</code> 阶。</li><li>确保在代码实现中，遍历的范围和数组索引的正确性。</li></ul><h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h1><p><a href="https://leetcode.cn/problems/edit-distance/description/">https://leetcode.cn/problems/edit-distance/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数。你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。设 <code>dp[i][j]</code> 表示将 <code>word1</code> 的前 <code>i</code> 个字符转换为 <code>word2</code> 的前 <code>j</code> 个字符所需的最少操作数。</p><p>具体步骤如下：</p><ol><li>初始化动态规划数组 <code>dp</code>，大小为 <code>(m+1) x (n+1)</code>，其中 <code>m</code> 和 <code>n</code> 分别是 <code>word1</code> 和 <code>word2</code> 的长度。</li><li>初始化 <code>dp[i][0]</code> 为 <code>i</code>，表示将 <code>word1</code> 的前 <code>i</code> 个字符转换为空字符串所需的操作数（全部删除）。</li><li>初始化 <code>dp[0][j]</code> 为 <code>j</code>，表示将空字符串转换为 <code>word2</code> 的前 <code>j</code> 个字符所需的操作数（全部插入）。</li><li>遍历每个字符，填充动态规划数组 <code>dp</code>：<ul><li>如果 <code>word1[i-1] == word2[j-1]</code>，则 <code>dp[i][j] = dp[i-1][j-1]</code>。</li><li>否则，<code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code>，分别表示替换、删除和插入操作。</li></ul></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-comment">// 填充 dp 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m * n)，其中 <code>m</code> 和 <code>n</code> 分别是 <code>word1</code> 和 <code>word2</code> 的长度。我们需要遍历所有的字符对来填充动态规划数组。</li><li><strong>空间复杂度</strong>: O(m * n)，用于存储动态规划数组 <code>dp</code>。</li></ul><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>我们可以进一步优化空间复杂度。因为在计算 <code>dp[i][j]</code> 时，只需要 <code>dp[i-1][j-1]</code>、<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code>，所以可以使用两个一维数组 <code>prev</code> 和 <code>curr</code> 代替二维数组 <code>dp</code>。</p><h3 id="优化后的代码实现"><a href="#优化后的代码实现" class="headerlink" title="优化后的代码实现"></a>优化后的代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-type">int</span>[] prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] curr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            prev[j] = j;<br>        &#125;<br><br>        <span class="hljs-comment">// 填充 dp 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            curr[<span class="hljs-number">0</span>] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    curr[j] = prev[j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    curr[j] = Math.min(prev[j - <span class="hljs-number">1</span>], Math.min(prev[j], curr[j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 更新 prev 数组</span><br>            <span class="hljs-type">int</span>[] temp = prev;<br>            prev = curr;<br>            curr = temp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> prev[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化后的复杂度分析"><a href="#优化后的复杂度分析" class="headerlink" title="优化后的复杂度分析"></a>优化后的复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m * n)，与之前相同。</li><li><strong>空间复杂度</strong>: O(n)，只使用了两个一维数组 <code>prev</code> 和 <code>curr</code>。</li></ul><h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h1><p><a href="https://leetcode.cn/problems/sort-colors/description/">https://leetcode.cn/problems/sort-colors/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色的顺序排列。我们使用整数 <code>0</code>、<code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。要求在不使用库内置的 <code>sort</code> 函数的情况下解决这个问题。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用双指针法来解决这个问题，通过两个指针将数组划分为三部分：红色（0）、白色（1）和蓝色（2）。</p><p>具体步骤如下：</p><ol><li>初始化两个指针 <code>p0</code> 和 <code>p2</code>，分别指向数组的开始和结束位置，用于交换 0 和 2。</li><li>使用一个指针 <code>i</code> 遍历数组：<ul><li>如果 <code>nums[i]</code> 等于 2，则将其与 <code>p2</code> 位置的元素交换，并将 <code>p2</code> 向左移动一位。</li><li>如果 <code>nums[i]</code> 等于 0，则将其与 <code>p0</code> 位置的元素交换，并将 <code>p0</code> 向右移动一位。</li><li>如果 <code>nums[i]</code> 等于 1，则继续遍历。</li></ul></li></ol><p>通过这种方式，数组可以被原地排序为红色、白色和蓝色。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p2 = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= p2; i++) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; p2 &amp;&amp; nums[i] == <span class="hljs-number">2</span>) &#123;<br>                nums[i] = nums[p2];<br>                nums[p2] = <span class="hljs-number">2</span>;<br>                p2--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                nums[i] = nums[p0];<br>                nums[p0] = <span class="hljs-number">0</span>;<br>                p0++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是数组的长度。我们只需遍历数组一次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用双指针 <code>p0</code> 和 <code>p2</code>，分别指向数组的开始和结束位置，通过交换元素实现原地排序。</li><li>遍历数组时，如果遇到 2，将其与 <code>p2</code> 位置的元素交换，并将 <code>p2</code> 向左移动一位。</li><li>如果遇到 0，将其与 <code>p0</code> 位置的元素交换，并将 <code>p0</code> 向右移动一位。</li><li>遇到 1 时，直接跳过，继续遍历。</li></ul><h1 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h1><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/">https://leetcode.cn/problems/minimum-window-substring/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>s</code> 和一个字符串 <code>t</code>。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code>。</p><p>注意：</p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用滑动窗口和哈希表来解决这个问题。具体步骤如下：</p><ol><li>初始化两个指针 <code>left</code> 和 <code>right</code>，表示滑动窗口的左右边界。初始化一个哈希表 <code>map</code>，记录 <code>t</code> 中每个字符的数量。</li><li>移动 <code>right</code> 指针扩大窗口，直到窗口包含 <code>t</code> 中所有字符。</li><li>移动 <code>left</code> 指针缩小窗口，直到窗口不能再缩小，记录当前最小窗口。</li><li>重复步骤 2 和 3，直到 <code>right</code> 指针到达字符串 <code>s</code> 的末尾。</li><li>返回记录的最小窗口。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br>        <span class="hljs-keyword">if</span> (m &lt; n) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 存放最短的前后指针</span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>, m&#125;;<br>        <span class="hljs-comment">// 哈希表存 t 中字符的个数</span><br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 双指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; m) &#123;<br>            <span class="hljs-comment">// 右指针右移</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(s.charAt(right))) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> map.get(s.charAt(right));<br>                map.put(s.charAt(right), num - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>                    count--;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 总数减为0时，左指针右移找最小</span><br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>                    <span class="hljs-keyword">if</span> (map.containsKey(s.charAt(left))) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> map.get(s.charAt(left));<br>                        map.put(s.charAt(left), num + <span class="hljs-number">1</span>);<br>                        <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-comment">// 找到最小</span><br>                            count++;<br>                            <span class="hljs-keyword">if</span> ((arr[<span class="hljs-number">1</span>] - arr[<span class="hljs-number">0</span>]) &gt; (right - left)) &#123;<br>                                arr[<span class="hljs-number">0</span>] = left;<br>                                arr[<span class="hljs-number">1</span>] = right;<br>                            &#125;<br>                            left++;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    left++;<br>                &#125;<br>            &#125;<br>            right++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">1</span>] - arr[<span class="hljs-number">0</span>] == m) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s.substring(arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m + n)，其中 m 是字符串 <code>s</code> 的长度，n 是字符串 <code>t</code> 的长度。遍历 <code>s</code> 和 <code>t</code> 各一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储 <code>t</code> 中字符的哈希表。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用滑动窗口和哈希表来记录字符及其数量。</li><li>移动 <code>right</code> 指针扩大窗口，直到窗口包含 <code>t</code> 中所有字符。</li><li>移动 <code>left</code> 指针缩小窗口，找到最小覆盖子串。</li><li>如果找不到符合条件的子串，返回空字符串 <code>&quot;&quot;</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-7</title>
    <link href="/2024/08/05/hot100-7/"/>
    <url>/2024/08/05/hot100-7/</url>
    
    <content type="html"><![CDATA[<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h1><p><a href="https://leetcode.cn/problems/jump-game/submissions/552558014/">https://leetcode.cn/problems/jump-game/submissions/552558014/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个非负整数数组 <code>nums</code>，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code>；否则，返回 <code>false</code>。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用贪心算法来解决这个问题。贪心算法的核心是不断更新能够到达的最远位置，并判断这个位置是否覆盖到数组的最后一个下标。</p><p>具体步骤如下：</p><ol><li>初始化一个变量 <code>distance</code>，表示当前能够到达的最远位置。</li><li>遍历数组 <code>nums</code>，对于每个元素 <code>nums[i]</code>：<ul><li>如果当前下标 <code>i</code> 大于 <code>distance</code>，说明不能再往前跳，直接返回 <code>false</code>。</li><li>更新 <code>distance</code> 为 <code>max(distance, i + nums[i])</code>，即考虑当前位置能跳跃的最远距离。</li><li>如果 <code>distance</code> 已经覆盖到数组的最后一个下标，返回 <code>true</code>。</li></ul></li><li>遍历结束后，如果 <code>distance</code> 仍然没有覆盖到最后一个下标，返回 <code>false</code>。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= distance; i++) &#123;<br>            <span class="hljs-comment">// 更新能够到达的最远位置</span><br>            distance = Math.max(distance, i + nums[i]);<br>            <span class="hljs-comment">// 判断是否已经能够到达最后一个下标</span><br>            <span class="hljs-keyword">if</span> (distance &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是数组的长度。我们只需遍历一次数组。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>贪心算法的核心在于不断更新能够到达的最远位置，并判断这个位置是否覆盖到数组的最后一个下标。</li><li>如果当前下标 <code>i</code> 大于 <code>distance</code>，说明不能再往前跳，直接返回 <code>false</code>。</li><li>初始化时，<code>distance</code> 变量设置为 0，表示从第一个下标开始跳跃。</li></ul><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h1><p><a href="https://leetcode.cn/problems/merge-intervals/description/">https://leetcode.cn/problems/merge-intervals/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start_i, end_i]</code>。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以按照起始位置对区间进行排序，然后遍历排序后的区间，合并重叠的区间。具体步骤如下：</p><ol><li>对区间数组按照起始位置进行排序，如果起始位置相同，则按结束位置排序。</li><li>遍历排序后的区间数组，使用一个变量 <code>currentInterval</code> 表示当前处理的区间：<ul><li>如果当前区间的结束位置 <code>currentInterval[1]</code> 大于等于下一个区间的起始位置 <code>sortedIntervals[i][0]</code>，说明有重叠，将当前区间的结束位置更新为两个区间结束位置的最大值。</li><li>如果没有重叠，则将 <code>currentInterval</code> 添加到结果列表中，并将当前区间更新为下一个区间。</li></ul></li><li>遍历结束后，将最后一个区间添加到结果列表中。</li><li>返回结果列表。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-comment">// 排序，首先按起始位置排序，如果起始位置相同，则按结束位置排序</span><br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b)</span> &#123;<br>                <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br><br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] currentInterval = intervals[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (currentInterval[<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-comment">// 有重叠，合并区间</span><br>                currentInterval[<span class="hljs-number">1</span>] = Math.max(currentInterval[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 没有重叠，添加前一个区间到列表并更新当前区间</span><br>                list.add(currentInterval);<br>                currentInterval = intervals[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加最后一个区间</span><br>        list.add(currentInterval);<br><br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n log n)，其中 n 是区间的数量。排序的时间复杂度为 O(n log n)，遍历区间的时间复杂度为 O(n)。</li><li><strong>空间复杂度</strong>: O(n)，用于存储结果列表和排序后的区间数组。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要对区间数组进行排序，以便于后续的合并操作。</li><li>在合并区间时，始终保持当前处理的区间，并更新其结束位置。</li><li>确保遍历结束后将最后一个区间添加到结果列表中，避免遗漏。</li></ul><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/description/">https://leetcode.cn/problems/unique-paths/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点标记为 “Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（标记为 “Finish”）。问总共有多少条不同的路径？</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。设 <code>dp[i][j]</code> 表示从起点到达位置 <code>(i, j)</code> 的路径数量。由于机器人只能向下或者向右移动，因此路径数量的状态转移方程为：</p><p>$$<br>dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]<br>$$</p><p>其中，<code>dp[i-1][j]</code> 表示从上方到达 <code>(i, j)</code> 的路径数量，<code>dp[i][j-1]</code> 表示从左方到达 <code>(i, j)</code> 的路径数量。</p><p>为了优化空间复杂度，我们可以使用一维数组 <code>dp</code> 来存储路径数量。每次更新 <code>dp[j]</code> 时，只需要 <code>dp[j]</code> 和 <code>dp[j-1]</code> 的值即可。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一维数组 <code>dp</code>，大小为 <code>n</code>，并设置 <code>dp[0] = 1</code>，表示从起点到第一列的路径数量。</li><li>遍历网格的每一行 <code>i</code>，对于每一行中的每一列 <code>j</code>，更新 <code>dp[j]</code>：<ul><li><code>dp[j] = dp[j] + dp[j-1]</code>，表示当前格子的路径数量等于上方格子和左方格子的路径数量之和。</li></ul></li><li>最后返回 <code>dp[n-1]</code>，即到达右下角的路径数量。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 初始化一维数组 dp</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 动态规划更新路径数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[j] = dp[j] + dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m * n)，其中 m 和 n 分别是网格的行数和列数。我们需要遍历整个网格进行动态规划更新。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是网格的列数。我们只使用了一维数组 <code>dp</code> 来存储路径数量。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>动态规划数组 <code>dp</code> 只需要初始化第一列的值，其他位置通过状态转移方程更新。</li><li>在每次更新 <code>dp[j]</code> 时，考虑的是当前格子上方和左方格子的路径数量之和。</li><li>使用一维数组优化空间复杂度，确保代码简洁高效。</li></ul><h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h1><p><a href="https://leetcode.cn/problems/minimum-path-sum/description/">https://leetcode.cn/problems/minimum-path-sum/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code>，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。我们使用一个一维数组 <code>dp</code> 来存储到达每个位置的最小路径和。</p><p>具体步骤如下：</p><ol><li>初始化一维数组 <code>dp</code>，大小为 <code>n</code>（网格的列数）。<code>dp[j]</code> 表示到达位置 <code>(i, j)</code> 的最小路径和。</li><li>初始化 <code>dp[0]</code> 为 <code>grid[0][0]</code>，表示从起点到第一个位置的路径和。</li><li>初始化 <code>dp</code> 数组的第一行，表示从起点到第一行每个位置的路径和。</li><li>遍历网格的每一行 <code>i</code>，对于每一行中的每一列 <code>j</code>，更新 <code>dp[j]</code>：<ul><li>如果 <code>j == 0</code>，表示在第一列，只能从上方移动下来，因此 <code>dp[j] = grid[i][j] + dp[j]</code>。</li><li>否则，<code>dp[j]</code> 取决于从左方或者从上方移动过来的最小路径和，即 <code>dp[j] = Math.min(dp[j-1], dp[j]) + grid[i][j]</code>。</li></ul></li><li>最后返回 <code>dp[n-1]</code>，即到达右下角的最小路径和。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">// 校验输入</span><br>        <span class="hljs-keyword">if</span> (grid == <span class="hljs-literal">null</span> || grid.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>        <span class="hljs-comment">// 初始化dp数组的第一行</span><br>        dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i] = grid[<span class="hljs-number">0</span>][i] + dp[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历每一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                    dp[j] = grid[i][j] + dp[j]; <span class="hljs-comment">// 第一列只能从上方移动下来</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[j] = Math.min(dp[j - <span class="hljs-number">1</span>], dp[j]) + grid[i][j]; <span class="hljs-comment">// 从左方或上方移动过来</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m * n)，其中 m 和 n 分别是网格的行数和列数。我们需要遍历整个网格进行动态规划更新。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是网格的列数。我们只使用了一维数组 <code>dp</code> 来存储路径和。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在遍历过程中，确保每个位置的路径和都是从上方或左方的最小路径和加上当前位置的值。</li><li>初始化 <code>dp</code> 数组的第一行，确保从起点到第一行每个位置的路径和正确。</li><li>在更新 <code>dp</code> 数组时，注意处理第一列的特殊情况，只能从上方移动下来。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-6</title>
    <link href="/2024/07/31/hot100-6/"/>
    <url>/2024/07/31/hot100-6/</url>
    
    <content type="html"><![CDATA[<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h1><p><a href="https://leetcode.cn/problems/permutations/description/">https://leetcode.cn/problems/permutations/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列。你可以按任意顺序返回答案。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来解决这个问题。回溯算法可以动态地构建所有可能的排列，并在满足条件时保存结果。具体步骤如下：</p><ol><li>初始化结果列表 <code>list</code> 和当前路径 <code>path</code>。</li><li>使用一个标志数组 <code>flag</code> 来记录每个数字是否已被使用。</li><li>定义一个回溯函数 <code>backtracking</code>，用于构建所有可能的排列：<ul><li>如果当前路径 <code>path</code> 的长度等于数组 <code>nums</code> 的长度，表示找到一个完整的排列，将其添加到结果列表 <code>list</code> 中。</li><li>否则，遍历数组 <code>nums</code>：<ul><li>如果当前数字已被使用，跳过。</li><li>将当前数字添加到路径 <code>path</code> 中，并标记为已使用。</li><li>递归调用 <code>backtracking</code> 继续构建排列。</li><li>递归返回后，移除路径 <code>path</code> 中的最后一个元素，并取消标记。</li></ul></li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; list;<br>    List&lt;Integer&gt; path;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list;<br>        <span class="hljs-type">boolean</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtracking(nums, flag);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] flag)</span> &#123;<br>        <span class="hljs-comment">// 如果当前路径长度等于数组长度，保存当前排列</span><br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 如果当前数字已被使用，跳过</span><br>            <span class="hljs-keyword">if</span> (flag[i]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 添加当前数字到路径中，并标记为已使用</span><br>            path.add(nums[i]);<br>            flag[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 递归构建下一个排列</span><br>            backtracking(nums, flag);<br>            <span class="hljs-comment">// 移除路径中的最后一个元素，并取消标记</span><br>            flag[i] = <span class="hljs-literal">false</span>;<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n!)，其中 n 是数组 <code>nums</code> 的长度。全排列的数量为 n!，每个排列的构建过程需要 O(n) 的时间。</li><li><strong>空间复杂度</strong>: O(n)，递归调用的最大深度为 n，另外需要 O(n) 的空间来存储临时的排列结果和标志数组。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用标志数组 <code>flag</code> 来记录每个数字是否已被使用，避免重复使用。</li><li>在每次找到一个完整排列时，创建当前路径 <code>path</code> 的副本，并添加到结果列表 <code>list</code> 中。</li><li>在递归返回后，及时移除路径中的最后一个元素，并取消标志，确保其他排列的构建不受影响。</li></ul><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h1><p><a href="https://leetcode.cn/problems/rotate-image/description/">https://leetcode.cn/problems/rotate-image/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 <code>n × n</code> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了在原地旋转矩阵，我们可以将矩阵分层处理，每次将四个角上的元素进行交换。具体步骤如下：</p><ol><li>将矩阵按照层进行处理，每一层将对应的四个位置的元素进行交换。</li><li>对于第 <code>i</code> 层的第 <code>j</code> 个元素 <code>matrix[i][i+j]</code>，它需要移动到 <code>matrix[i+j][n-i-1]</code>，即右侧。</li><li>依次将四个位置的元素进行交换，直到所有层都处理完毕。</li></ol><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>遍历每一层，范围是从 0 到 <code>n/2</code>。</li><li>对于每一层，遍历该层中的元素，范围是从 0 到 <code>n-i*2-1</code>。</li><li>对于每一个元素，进行四次交换：<ul><li>将 <code>matrix[i][i+j]</code> 移动到 <code>matrix[i+j][n-i-1]</code>。</li><li>将 <code>matrix[n-i-1-j][i]</code> 移动到 <code>matrix[i][i+j]</code>。</li><li>将 <code>matrix[n-i-1][n-i-1-j]</code> 移动到 <code>matrix[n-i-1-j][i]</code>。</li><li>将 <code>matrix[i+j][n-i-1]</code> 移动到 <code>matrix[n-i-1][n-i-1-j]</code>。</li></ul></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 遍历每一层</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 遍历每层中的元素</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][i + j];<br>                <span class="hljs-comment">// 将左下角的元素移到左上角</span><br>                matrix[i][i + j] = matrix[n - i - <span class="hljs-number">1</span> - j][i];<br>                <span class="hljs-comment">// 将右下角的元素移到左下角</span><br>                matrix[n - i - <span class="hljs-number">1</span> - j][i] = matrix[n - i - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span> - j];<br>                <span class="hljs-comment">// 将右上角的元素移到右下角</span><br>                matrix[n - i - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span> - j] = matrix[i + j][n - i - <span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// 将临时变量中的元素（原左上角）移到右上角</span><br>                matrix[i + j][n - i - <span class="hljs-number">1</span>] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n^2)，其中 n 是矩阵的边长。我们需要遍历矩阵中的每一个元素进行交换。</li><li><strong>空间复杂度</strong>: O(1)，我们只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保在遍历每一层时，不要越界。</li><li>注意每次交换四个位置的顺序，确保每个元素都正确移动到其新位置。</li><li>直接在输入的二维矩阵上进行操作，不要使用额外的矩阵。</li></ul><h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h1><p><a href="https://leetcode.cn/problems/group-anagrams/description/">https://leetcode.cn/problems/group-anagrams/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词是由重新排列源单词的所有字母得到的一个新单词。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用哈希表来解决这个问题。对于每个字符串，将其字符排序后作为键，将所有具有相同排序结果的字符串分组到一起。</p><p>具体步骤如下：</p><ol><li>初始化一个哈希表 <code>map</code>，键为排序后的字符串，值为字母异位词列表。</li><li>遍历字符串数组 <code>strs</code>：<ul><li>将每个字符串转换为字符数组并排序。</li><li>将排序后的字符数组转换为字符串作为键。</li><li>将原字符串添加到对应键的列表中。</li></ul></li><li>返回哈希表中所有值的列表，即所有字母异位词的分组。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-comment">// 初始化哈希表</span><br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 遍历字符串数组</span><br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-comment">// 将字符串转换为字符数组并排序</span><br>            <span class="hljs-type">char</span>[] arr = str.toCharArray();<br>            Arrays.sort(arr);<br>            <span class="hljs-comment">// 将排序后的字符数组转换为字符串</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">newLetter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr);<br>            <span class="hljs-comment">// 获取哈希表中对应键的列表，没有则创建新列表</span><br>            List&lt;String&gt; list = map.getOrDefault(newLetter, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            <span class="hljs-comment">// 将原字符串添加到列表中</span><br>            list.add(str);<br>            <span class="hljs-comment">// 将列表存入哈希表</span><br>            map.put(newLetter, list);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回哈希表中所有值的列表</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n * k * log k)，其中 n 是字符串数组的长度，k 是字符串的最大长度。对每个字符串排序的时间复杂度为 O(k * log k)，遍历字符串数组的时间复杂度为 O(n)。</li><li><strong>空间复杂度</strong>: O(n * k)，其中 n 是字符串数组的长度，k 是字符串的最大长度。用于存储哈希表和字符数组。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>字符排序后的结果作为哈希表的键，可以唯一地标识字母异位词。</li><li>使用 <code>Arrays.sort</code> 对字符数组进行排序，并将排序后的字符数组转换为字符串，保证能够正确分组字母异位词。</li><li>最终返回哈希表中所有值的列表，即所有字母异位词的分组。</li></ul><h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h1><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">https://leetcode.cn/problems/maximum-subarray/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。动态规划可以帮助我们在遍历数组的过程中，找到以每个元素结尾的最大子数组和，从而得到整个数组的最大子数组和。</p><p>具体步骤如下：</p><ol><li>初始化两个变量 <code>pre</code> 和 <code>ans</code>。<code>pre</code> 表示以当前元素结尾的最大子数组和，<code>ans</code> 表示全局最大子数组和。</li><li>遍历数组 <code>nums</code>，对于每个元素 <code>nums[i]</code>：<ul><li>更新 <code>pre</code> 为 <code>max(nums[i], pre + nums[i])</code>，即以当前元素结尾的最大子数组和。</li><li>更新 <code>ans</code> 为 <code>max(ans, pre)</code>，即全局最大子数组和。</li></ul></li><li>返回 <code>ans</code> 作为结果。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化为数组的第一个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 计算以当前元素结尾的最大子数组和</span><br>            pre = Math.max(nums[i], pre + nums[i]);<br>            <span class="hljs-comment">// 更新全局最大子数组和</span><br>            ans = Math.max(ans, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是数组的长度。我们只需遍历一次数组。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>动态规划的核心在于找到以每个元素结尾的最大子数组和，并在过程中更新全局最大子数组和。</li><li>初始化 <code>ans</code> 为数组的第一个元素，确保在数组只有一个元素时也能正确返回结果。</li><li>在遍历过程中，及时更新 <code>pre</code> 和 <code>ans</code>，确保能够得到全局最大子数组和。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-5</title>
    <link href="/2024/07/30/hot100-5/"/>
    <url>/2024/07/30/hot100-5/</url>
    
    <content type="html"><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">https://leetcode.cn/problems/search-in-rotated-sorted-array/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值互不相同。在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（0 &lt;&#x3D; k &lt; nums.length）上进行了旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标从 0 开始计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>。</p><p>给你旋转后的数组 <code>nums</code> 和一个整数 <code>target</code>，如果 <code>nums</code> 中存在这个目标值 <code>target</code>，则返回它的下标，否则返回 -1。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用二分查找算法来解决这个问题。通过二分查找，我们可以在 O(log n) 的时间复杂度内找到目标值。在旋转数组中，至少有一半是有序的，通过判断哪一半有序，可以确定目标值是否在有序部分，从而决定搜索的范围。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化两个指针 <code>left</code> 和 <code>right</code>，分别指向数组的左右两端。</li><li>进行二分查找，直到 <code>left</code> 超过 <code>right</code>：<ul><li>计算中间位置 <code>mid</code>。</li><li>如果 <code>nums[mid]</code> 等于目标值 <code>target</code>，直接返回 <code>mid</code>。</li><li>判断哪一半是有序的：<ul><li>如果 <code>nums[mid]</code> 到 <code>nums[right]</code> 是有序的：<ul><li>判断目标值 <code>target</code> 是否在这个有序范围内：<ul><li>如果是，则继续在右半部分进行二分查找。</li><li>否则，在左半部分进行二分查找。</li></ul></li></ul></li><li>如果 <code>nums[left]</code> 到 <code>nums[mid]</code> 是有序的：<ul><li>判断目标值 <code>target</code> 是否在这个有序范围内：<ul><li>如果是，则继续在左半部分进行二分查找。</li><li>否则，在右半部分进行二分查找。</li></ul></li></ul></li></ul></li></ul></li><li>如果没有找到目标值，返回 -1。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 初始化左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 二分查找</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br><br>            <span class="hljs-comment">// 如果中间值等于目标值，返回中间值的索引</span><br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断哪一半是有序的</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[right]) &#123;<br>                <span class="hljs-comment">// 右半部分有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<br>                    left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 在右半部分查找</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 在左半部分查找</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 左半部分有序</span><br>                <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                    right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 在左半部分查找</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 在右半部分查找</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果没有找到目标值，返回 -1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(log n)，因为使用了二分查找算法。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>要特别注意边界条件的判断，确保二分查找的范围正确。</li><li>判断哪一半是有序的，可以通过比较 <code>nums[mid]</code> 与 <code>nums[right]</code> 或 <code>nums[mid]</code> 与 <code>nums[left]</code> 来进行。</li><li>处理旋转数组的关键是利用二分查找的特性，通过判断哪一半是有序的来缩小查找范围。</li></ul><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用二分查找来找到目标值在数组中的开始位置和结束位置。首先，我们需要找到目标值的左边界，然后再找到右边界。</p><ol><li><p>使用二分查找找到目标值的左边界：</p><ul><li>初始化 <code>left</code> 为 0，<code>right</code> 为数组长度。</li><li>在循环中，计算中间位置 <code>mid</code>。</li><li>如果 <code>nums[mid]</code> 小于目标值 <code>target</code>，则将 <code>left</code> 移动到 <code>mid + 1</code>。</li><li>否则，将 <code>right</code> 移动到 <code>mid</code>。</li><li>循环结束后，如果 <code>nums[left]</code> 不等于 <code>target</code>，说明数组中不存在目标值，返回 <code>[-1, -1]</code>。</li><li>否则，记录左边界位置。</li></ul></li><li><p>使用二分查找找到目标值的右边界：</p><ul><li>初始化 <code>right</code> 为数组长度。</li><li>在循环中，计算中间位置 <code>mid</code>。</li><li>如果 <code>nums[mid]</code> 小于等于目标值 <code>target</code>，则将 <code>left</code> 移动到 <code>mid + 1</code>。</li><li>否则，将 <code>right</code> 移动到 <code>mid</code>。</li><li>循环结束后，记录右边界位置为 <code>right - 1</code>。</li></ul></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 初始化结果数组</span><br>        <span class="hljs-type">int</span>[] ans = &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-comment">// 边界条件处理</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span> || nums[<span class="hljs-number">0</span>] &gt; target || nums[nums.length - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">return</span> ans;<br><br>        <span class="hljs-comment">// 二分查找左边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查左边界是否存在目标值</span><br>        <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target) <span class="hljs-keyword">return</span> ans;<br>        ans[<span class="hljs-number">0</span>] = left;<br><br>        <span class="hljs-comment">// 二分查找右边界</span><br>        right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        ans[<span class="hljs-number">1</span>] = right - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(log n)，其中 n 是数组的长度。二分查找的时间复杂度为 O(log n)。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>二分查找的左右边界初始化为数组的开始和结束位置。</li><li>找左边界时，确保找到的第一个等于目标值的索引。</li><li>找右边界时，确保找到的最后一个等于目标值的索引。</li><li>检查左边界是否存在目标值，以避免数组中不存在目标值时返回错误结果。</li></ul><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p><a href="https://leetcode.cn/problems/combination-sum/description/">https://leetcode.cn/problems/combination-sum/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个无重复元素的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code>，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有不同组合，并以列表形式返回。你可以按任意顺序返回这些组合。</p><p><code>candidates</code> 中的同一个数字可以无限制重复被选取。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 150 个。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来解决这个问题。回溯算法可以动态地构建所有可能的组合，并在满足条件时保存结果。具体步骤如下：</p><ol><li>初始化结果列表 <code>list</code> 和当前路径 <code>path</code>。</li><li>对 <code>candidates</code> 数组进行排序，这样可以提前结束不必要的递归。</li><li>定义一个回溯函数 <code>backtracking</code>，用于构建和为 <code>target</code> 的所有组合：<ul><li>如果当前和 <code>sum</code> 等于 <code>target</code>，将当前路径 <code>path</code> 添加到结果列表 <code>list</code> 中。</li><li>否则，遍历 <code>candidates</code> 数组，从当前索引 <code>startIndex</code> 开始，避免重复组合。</li><li>如果当前和 <code>sum</code> 加上 <code>candidates[i]</code> 大于 <code>target</code>，则提前结束递归。</li><li>否则，将 <code>candidates[i]</code> 添加到当前路径 <code>path</code> 中，并递归调用 <code>backtracking</code> 继续构建组合。</li><li>递归返回后，移除当前路径 <code>path</code> 中的最后一个元素，继续探索其他组合。</li></ul></li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; list;<br>    List&lt;Integer&gt; path;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (candidates == <span class="hljs-literal">null</span> || candidates.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list;<br>        Arrays.sort(candidates);<br>        <span class="hljs-keyword">if</span> (candidates[<span class="hljs-number">0</span>] &gt; target) <span class="hljs-keyword">return</span> list;<br>        backtracking(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-comment">// 如果当前和等于目标值，保存当前组合</span><br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历候选数组，从当前索引开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-comment">// 如果当前和加上候选数大于目标值，提前结束递归</span><br>            <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) <span class="hljs-keyword">return</span>;<br>            <br>            <span class="hljs-comment">// 添加当前候选数到路径中</span><br>            path.add(candidates[i]);<br>            <span class="hljs-comment">// 递归构建下一个组合，允许重复使用当前候选数</span><br>            backtracking(candidates, target, sum + candidates[i], i);<br>            <span class="hljs-comment">// 移除路径中的最后一个元素，探索其他组合</span><br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: 取决于目标值 <code>target</code> 和 <code>candidates</code> 数组的大小。在最坏情况下，每个元素都可能被选取多次，因此复杂度接近于指数级别，具体取决于问题的输入和输出规模。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是目标值 <code>target</code>。递归调用的最大深度与目标值 <code>target</code> 成正比。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>由于可以无限次使用 <code>candidates</code> 中的元素，递归时要传入当前索引 <code>startIndex</code>，以避免生成重复组合。</li><li>对 <code>candidates</code> 数组进行排序，可以在递归过程中提前结束不必要的递归，提高算法效率。</li><li>每次找到一个和为 <code>target</code> 的组合时，都需要将当前路径 <code>path</code> 的一个副本添加到结果列表 <code>list</code> 中，以避免引用问题。</li></ul><h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h1><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">https://leetcode.cn/problems/trapping-rain-water/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用单调栈来解决这个问题。单调栈可以帮助我们快速找到左边和右边的较高柱子，从而计算出当前柱子能接的雨水量。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个栈 <code>st</code> 和一个变量 <code>sum</code> 来存储接到的雨水总量。</li><li>遍历高度数组 <code>height</code>：<ul><li>如果当前高度 <code>height[current]</code> 大于栈顶元素的高度，说明形成了一个凹槽，可以接到雨水。</li><li>弹出栈顶元素，作为凹槽的底部高度 <code>h</code>。</li><li>如果栈为空，说明没有左边界，不能形成凹槽，跳出循环。</li><li>计算左边界和当前高度之间的距离 <code>distance</code> 和较低的高度 <code>min</code>。</li><li>计算当前凹槽能接到的雨水量，并累加到总量 <code>sum</code> 中。</li><li>将当前索引 <code>current</code> 压入栈中。</li></ul></li><li>返回接到的雨水总量 <code>sum</code>。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 初始化接雨水总量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 使用单调栈</span><br>        ArrayDeque&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">// 当前遍历索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历高度数组</span><br>        <span class="hljs-keyword">while</span> (current &lt; height.length) &#123;<br>            <span class="hljs-comment">// 当栈不为空且当前高度大于栈顶高度时</span><br>            <span class="hljs-keyword">while</span> (!st.isEmpty() &amp;&amp; height[current] &gt; height[st.peek()]) &#123;<br>                <span class="hljs-comment">// 弹出栈顶元素，作为凹槽的底部高度</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> height[st.peek()];<br>                st.poll();<br>                <span class="hljs-comment">// 如果栈为空，跳出循环</span><br>                <span class="hljs-keyword">if</span> (st.isEmpty()) <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-comment">// 计算左边界和当前高度之间的距离</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> current - st.peek() - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 计算较低的高度</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(height[st.peek()], height[current]);<br>                <span class="hljs-comment">// 计算当前凹槽能接到的雨水量，并累加到总量</span><br>                sum = sum + distance * (min - h);<br>            &#125;<br>            <span class="hljs-comment">// 将当前索引压入栈中</span><br>            st.push(current);<br>            <span class="hljs-comment">// 移动到下一个柱子</span><br>            current++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是高度数组的长度。每个元素最多被栈操作一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储栈中的元素。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>单调栈用于记录柱子的索引，而不是高度值。</li><li>当栈为空时，说明没有左边界，无法形成凹槽接雨水。</li><li>计算凹槽的雨水量时，注意 <code>distance</code> 和 <code>min</code> 的计算方法，确保准确计算每个凹槽的雨水量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-4</title>
    <link href="/2024/07/30/hot100-4/"/>
    <url>/2024/07/30/hot100-4/</url>
    
    <content type="html"><![CDATA[<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h1><p><a href="https://leetcode.cn/problems/generate-parentheses/description/">https://leetcode.cn/problems/generate-parentheses/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于生成所有可能的并且有效的括号组合。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来生成所有可能的括号组合。在构建括号组合的过程中，我们需要确保生成的括号序列始终有效。具体来说，任意前缀中左括号的数量必须大于或等于右括号的数量。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个结果列表 <code>ans</code> 用于存储所有有效的括号组合，并使用一个 <code>StringBuilder</code> 对象 <code>sb</code> 来构建当前的括号序列。</li><li>定义一个回溯函数 <code>backtracking</code>，它接受两个参数：剩余的左括号数量 <code>left</code> 和剩余的右括号数量 <code>right</code>。</li><li>在回溯函数中：<ul><li>如果左右括号数量都为0，说明当前构建的括号序列是有效的，将其加入结果列表 <code>ans</code> 中。</li><li>如果还有左括号可以使用，则添加一个左括号，并递归调用回溯函数。</li><li>如果右括号数量大于左括号数量，则添加一个右括号，并递归调用回溯函数。</li><li>在递归返回之前，撤销上一步的选择，即从 <code>sb</code> 中删除最后一个字符。</li></ul></li><li>调用回溯函数开始生成所有可能的括号组合。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 结果列表</span><br>    List&lt;String&gt; ans;<br>    <span class="hljs-comment">// 用于构建当前括号序列</span><br>    StringBuilder sb;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 初始化结果列表</span><br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始化 StringBuilder</span><br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// 开始回溯</span><br>        backtracking(n, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 如果左右括号数量都为 0，添加当前序列到结果列表</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>            ans.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果还有左括号可以使用，添加一个左括号并递归</span><br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            backtracking(left - <span class="hljs-number">1</span>, right);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果右括号数量大于左括号数量，添加一个右括号并递归</span><br>        <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; left &lt; right) &#123;<br>            sb.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            backtracking(left, right - <span class="hljs-number">1</span>);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(4^n &#x2F; √n)，生成所有可能的括号组合数量为卡特兰数，这里的时间复杂度是卡特兰数的上界。</li><li><strong>空间复杂度</strong>: O(n)，递归的深度最大为 <code>2n</code>，每次递归调用使用的空间为 O(1)。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在构建括号序列时，必须确保右括号的数量始终不大于左括号的数量。</li><li>使用 <code>StringBuilder</code> 来构建当前的括号序列，避免多次字符串拼接的开销。</li><li>在递归返回之前，撤销上一步的选择，以确保构建其他可能的组合时不受影响。</li></ul><h1 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a>23. 合并 K 个升序链表</h1><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">https://leetcode.cn/problems/merge-k-sorted-lists/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用最小堆（优先队列）来合并 <code>k</code> 个已排序的链表。最小堆能够在 O(log k) 的时间复杂度内获取和删除最小元素，使我们可以高效地找到所有链表中当前最小的节点。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个最小堆 <code>PriorityQueue</code>，用来存储每个链表的节点。堆的大小为 <code>k</code>。</li><li>将每个链表的第一个节点加入最小堆。</li><li>创建一个哨兵节点 <code>dummy</code> 作为合并后链表的头节点，并初始化一个指针 <code>pre</code> 指向哨兵节点。</li><li>不断从最小堆中取出当前最小的节点，将其加入合并后的链表中，并将指针 <code>pre</code> 移动到新加入的节点。</li><li>如果被取出的节点还有下一个节点，则将下一个节点加入最小堆。</li><li>当最小堆为空时，合并完成，返回哨兵节点的下一个节点作为合并后的链表的头节点。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-comment">// 如果链表数组为空或长度为0，直接返回null</span><br>        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 创建一个长度为k的最小堆</span><br>        PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(lists.length, (a, b) -&gt; Integer.compare(a.val, b.val));<br><br>        <span class="hljs-comment">// 将每个链表的第一个节点加入最小堆</span><br>        <span class="hljs-keyword">for</span> (ListNode list : lists) &#123;<br>            <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span>) &#123;<br>                pq.offer(list);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建哨兵节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br><br>        <span class="hljs-comment">// 不断从最小堆中取出当前最小的节点，将其加入合并后的链表中</span><br>        <span class="hljs-keyword">while</span> (pq.peek() != <span class="hljs-literal">null</span>) &#123;<br>            pre.next = pq.poll();<br>            pre = pre.next;<br>            <span class="hljs-comment">// 如果被取出的节点还有下一个节点，将下一个节点加入最小堆</span><br>            <span class="hljs-keyword">if</span> (pre.next != <span class="hljs-literal">null</span>) &#123;<br>                pq.offer(pre.next);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回哨兵节点的下一个节点作为合并后的链表的头节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(N log k)，其中 N 是所有链表中节点的总数，k 是链表的数量。每次插入和删除操作的时间复杂度为 O(log k)，总共进行 N 次操作。</li><li><strong>空间复杂度</strong>: O(k)，用于存储最小堆中最多 k 个节点。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要处理输入为空或长度为 0 的情况，直接返回 null。</li><li>使用最小堆可以高效地合并多个已排序的链表，每次操作的时间复杂度为 O(log k)。</li><li>哨兵节点可以简化链表操作，避免处理头节点为空的特殊情况。</li></ul><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><p><a href="https://leetcode.cn/problems/next-permutation/description/">https://leetcode.cn/problems/next-permutation/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>整数数组的一个排列就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr &#x3D; [1,2,3]，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]。<br>整数数组的下一个排列是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的下一个排列就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2]。类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2]。而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3]，因为 [3,2,1] 不存在一个字典序更大的排列。</p><p>给你一个整数数组 <code>nums</code>，找出 <code>nums</code> 的下一个排列。必须原地修改，只允许使用额外常数空间。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>要找到下一个字典序更大的排列，我们可以按以下步骤操作：</p><ol><li>从后向前查找第一个相邻升序对 <code>(i-1, i)</code>，满足 <code>nums[i-1] &lt; nums[i]</code>。这样可以确定需要调整的部分。</li><li>在从右往左找到的第一个升序对中，找出右侧部分中比 <code>nums[i-1]</code> 大的最小元素，并交换它们。</li><li>将右侧部分从 <code>i</code> 开始的元素逆序排列，以得到最小的字典序。</li></ol><h3 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>从数组末尾向前查找第一个 <code>nums[i-1] &lt; nums[i]</code> 的位置 <code>i-1</code>。</li><li>如果找到了这样的 <code>i-1</code>，则在 <code>i</code> 到末尾之间查找比 <code>nums[i-1]</code> 大的最小元素 <code>nums[j]</code>，交换 <code>nums[i-1]</code> 和 <code>nums[j]</code>。</li><li>将位置 <code>i</code> 到末尾的部分进行反转，使其变成最小字典序。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 特殊情况处理</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br><br>        <span class="hljs-comment">// 从后向前查找第一个升序对</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果找到了升序对</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 从后向前找比 nums[i] 大的最小元素</span><br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span> (j = len - <span class="hljs-number">1</span>; j &gt; i; j--) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 交换 nums[i] 和 nums[j]</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = tmp;<br>        &#125;<br><br>        <span class="hljs-comment">// 反转 i 之后的部分</span><br>        reverse(nums, i + <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[start];<br>            nums[start] = nums[end];<br>            nums[end] = tmp;<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是数组的长度。最坏情况下需要遍历数组三次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>从后向前查找第一个升序对 <code>(i-1, i)</code>，确保找到的调整位置是字典序最小的。</li><li>交换元素时，确保选择的是比 <code>nums[i-1]</code> 大的最小元素，以获得下一个更大的排列。</li><li>最后一步的反转操作是为了将调整位置后的部分变成最小字典序，从而确保整体排列是下一个字典序更大的排列。</li></ul><h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h1><p><a href="https://leetcode.cn/problems/longest-valid-parentheses/description/">https://leetcode.cn/problems/longest-valid-parentheses/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划的方法来解决这个问题。我们定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以索引 <code>i</code> 结尾的最长有效括号子串的长度。</p><h3 id="详细步骤-3"><a href="#详细步骤-3" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个 <code>dp</code> 数组，长度与字符串 <code>s</code> 相同，初始值都为 0。</li><li>遍历字符串 <code>s</code>，从索引 1 开始：<ul><li>如果 <code>s[i]</code> 是 ‘)’ 并且前一个字符 <code>s[i-1]</code> 是 ‘(‘，则我们找到了一对有效括号：<ul><li><code>dp[i] = dp[i-2] + 2</code>，这里 <code>dp[i-2]</code> 是在当前这对有效括号之前的最长有效括号子串的长度。</li></ul></li><li>如果 <code>s[i]</code> 是 ‘)’ 并且前一个字符 <code>s[i-1]</code> 是 ‘)’，则我们需要检查 <code>s[i-dp[i-1]-1]</code> 是否是 ‘(‘：<ul><li>如果是，则 <code>dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2</code>，其中 <code>dp[i-1]</code> 是前一个位置的最长有效括号子串长度，<code>dp[i-dp[i-1]-2]</code> 是在当前有效子串之前的最长有效括号子串的长度。</li></ul></li></ul></li><li>更新 <code>maxLength</code> 为 <code>dp[i]</code> 中的最大值。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 初始化最大长度为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 动态规划数组</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br><br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 如果当前字符是&#x27;)&#x27;</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 检查前一个字符是否是&#x27;(&#x27;</span><br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <br>                <span class="hljs-comment">// 如果前一个字符是&#x27;)&#x27;，并且在前一个有效括号子串之前有一个&#x27;(&#x27;</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + ((i - dp[i - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-comment">// 更新最大长度</span><br>                maxLength = Math.max(maxLength, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是字符串的长度。我们只需遍历字符串一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储动态规划数组 <code>dp</code>。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>动态规划数组 <code>dp</code> 用于存储以每个索引结尾的最长有效括号子串的长度。</li><li>在计算 <code>dp[i]</code> 时，需要根据当前字符和前一个字符的不同情况进行不同的处理。</li><li><code>maxLength</code> 记录了遍历过程中找到的最长有效括号子串的长度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-3</title>
    <link href="/2024/07/30/hot100-3/"/>
    <url>/2024/07/30/hot100-3/</url>
    
    <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来解决这个问题。回溯算法能够在构建解决方案的过程中动态地撤销已经做出的选择，从而可以探索所有可能的组合。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个映射数组 <code>lettermap</code>，将数字与其对应的字母关联起来。</li><li>初始化结果列表 <code>ans</code> 和一个用于构建组合的 <code>StringBuilder</code> 对象 <code>sb</code>。</li><li>如果输入的字符串为空，直接返回空列表。</li><li>使用回溯函数 <code>backtracking</code> 来生成所有可能的组合：<ul><li>如果当前索引等于输入字符串的长度，表示已经生成了一个完整的组合，将其加入结果列表。</li><li>否则，获取当前数字对应的字母集，然后依次尝试每个字母，并递归调用 <code>backtracking</code> 生成下一层的组合。</li><li>在递归返回之前，撤销上一步的选择，即从 <code>sb</code> 中删除最后一个字符。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] lettermap =&#123;<br>        <span class="hljs-string">&quot; &quot;</span>,    <span class="hljs-comment">// 0</span><br>        <span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// 1</span><br>        <span class="hljs-string">&quot;abc&quot;</span>,  <span class="hljs-comment">// 2</span><br>        <span class="hljs-string">&quot;def&quot;</span>,  <span class="hljs-comment">// 3</span><br>        <span class="hljs-string">&quot;ghi&quot;</span>,  <span class="hljs-comment">// 4</span><br>        <span class="hljs-string">&quot;jkl&quot;</span>,  <span class="hljs-comment">// 5</span><br>        <span class="hljs-string">&quot;mno&quot;</span>,  <span class="hljs-comment">// 6</span><br>        <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>        <span class="hljs-string">&quot;tuv&quot;</span>,  <span class="hljs-comment">// 8</span><br>        <span class="hljs-string">&quot;wxyz&quot;</span>  <span class="hljs-comment">// 9</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> StringBuilder sb;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; ans;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-comment">// 如果输入为空，返回空列表</span><br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始化结果列表和 StringBuilder</span><br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// 开始回溯</span><br>        backtracking(<span class="hljs-number">0</span>, digits);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> startIndex, String digits)</span> &#123;<br>        <span class="hljs-comment">// 如果当前索引等于输入字符串的长度，添加组合到结果列表</span><br>        <span class="hljs-keyword">if</span> (startIndex == digits.length()) &#123;<br>            ans.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获取当前数字对应的字母集</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> digits.charAt(startIndex) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lettermap[tmp].length(); i++) &#123;<br>            <span class="hljs-comment">// 选择一个字母</span><br>            sb.append(lettermap[tmp].charAt(i));<br>            <span class="hljs-comment">// 递归生成下一层的组合</span><br>            backtracking(startIndex + <span class="hljs-number">1</span>, digits);<br>            <span class="hljs-comment">// 撤销上一步选择</span><br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(3^n * 4^m)，其中 n 是对应 3 个字母的数字（如 2, 3, 4, 5, 6, 8）出现的次数，m 是对应 4 个字母的数字（如 7, 9）出现的次数。每次递归调用都会尝试所有可能的字母组合。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是输入字符串的长度。递归调用的深度最多为 n，另外需要 O(n) 的空间来存储临时的组合结果。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>回溯算法在生成组合时，先尝试一个字母，再递归生成下一个字母的组合，最终形成完整的字母组合。</li><li>使用 <code>StringBuilder</code> 来动态构建字符串，并在递归返回时撤销上一步的选择，可以有效减少字符串拼接的开销。</li><li>输入为空字符串时，直接返回空列表，避免不必要的计算。</li></ul><h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了删除链表的倒数第 <code>n</code> 个结点，我们可以使用快慢指针方法。</p><p>使用一个哨兵节点 <code>dummy</code>，指向链表的头节点。这样，即使删除头节点也能方便处理。<br>初始化两个指针 <code>slow</code> 和 <code>fast</code>，都指向哨兵节点。先让快指针 <code>fast</code> 走 <code>n</code> 步。然后同时移动快指针和慢指针，直到快指针到达链表的末尾。此时，慢指针 <code>slow</code> 的下一个节点就是要删除的节点。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个哨兵节点 <code>dummy</code>，并指向链表的头节点 <code>head</code>。</li><li>初始化两个指针 <code>slow</code> 和 <code>fast</code>，都指向哨兵节点 <code>dummy</code>。</li><li>让快指针 <code>fast</code> 先走 <code>n</code> 步。</li><li>继续同时移动 <code>slow</code> 和 <code>fast</code>，直到 <code>fast</code> 的下一个节点为空。</li><li>此时，<code>slow</code> 的下一个节点就是要删除的节点，将 <code>slow</code> 的下一个节点指向其下下个节点。</li><li>返回 <code>dummy</code> 的下一个节点作为新的头节点。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 创建哨兵节点并指向头节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-comment">// 初始化快慢指针</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy, fast = dummy;<br>        <br>        <span class="hljs-comment">// 快指针先走 n 步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 同时移动快慢指针，直到快指针到达链表末尾</span><br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 删除慢指针的下一个节点</span><br>        slow.next = slow.next.next;<br>        <br>        <span class="hljs-comment">// 返回新的头节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(L)，其中 L 是链表的长度。两个指针总共遍历了链表两次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用哨兵节点可以方便处理删除头节点的情况，避免单独处理这种特殊情况。</li><li>快指针先走 <code>n</code> 步，确保了在快指针到达链表末尾时，慢指针正好在需要删除的节点前一个位置。</li><li>如果链表为空或 <code>n</code> 超过链表长度，需要提前进行检查。</li></ul><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">https://leetcode.cn/problems/valid-parentheses/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 <code>s</code>，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了判断一个字符串中的括号是否有效，我们可以使用栈来辅助匹配括号。具体步骤如下：</p><ol><li>遍历字符串 <code>s</code> 中的每一个字符：<ul><li>如果是左括号，将其压入栈中。</li><li>如果是右括号，检查栈是否为空。如果栈为空，说明没有匹配的左括号，字符串无效。否则，弹出栈顶元素，并检查是否与当前右括号匹配。</li></ul></li><li>遍历完成后，如果栈为空，说明所有的左括号都匹配了相应的右括号，字符串有效。否则，字符串无效。</li></ol><h3 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个栈来存储左括号。</li><li>遍历字符串 <code>s</code>，对于每个字符：<ul><li>如果是左括号，将其压入栈中。</li><li>如果是右括号，检查栈是否为空。如果为空，返回 <code>false</code>。否则，弹出栈顶元素，并检查是否与当前右括号匹配。如果不匹配，返回 <code>false</code>。</li></ul></li><li>遍历完成后，检查栈是否为空。如果为空，返回 <code>true</code>，否则返回 <code>false</code>。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 栈用于存储左括号</span><br>        <span class="hljs-type">char</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[s.length()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历字符串中的每个字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-comment">// 如果是左括号，压入栈中</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                stack[top++] = c;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果是右括号，检查栈是否为空或栈顶是否匹配</span><br>                <span class="hljs-keyword">if</span> (top == <span class="hljs-number">0</span> || stack[top - <span class="hljs-number">1</span>] != getMatchingLeftBracket(c)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                top--; <span class="hljs-comment">// 匹配成功，弹出栈顶元素</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 栈为空，说明所有括号匹配成功</span><br>        <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回对应的左括号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getMatchingLeftBracket</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是字符串的长度。我们只遍历一次字符串。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是字符串的长度。最坏情况下栈中会存储所有的左括号。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>栈顶元素和当前右括号匹配时，弹出栈顶元素。</li><li>如果栈为空或栈顶元素不匹配，直接返回 <code>false</code>。</li><li>遍历结束后，检查栈是否为空，以判断所有的括号是否都匹配成功。</li></ul><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">https://leetcode.cn/problems/merge-two-sorted-lists/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了合并两个升序链表，我们可以使用双指针方法，同时遍历两个链表，将较小的节点依次加入到新的链表中。为了简化操作，我们可以使用一个哨兵节点来指向新链表的头节点。</p><h3 id="详细步骤-3"><a href="#详细步骤-3" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个哨兵节点 <code>dummy</code>，并初始化一个指针 <code>pre</code> 指向哨兵节点。</li><li>同时遍历两个链表 <code>list1</code> 和 <code>list2</code>：<ul><li>比较当前节点的值，将较小的节点加入到新链表中，并移动指针到下一个节点。</li><li>更新 <code>pre</code> 指向新链表的最新节点。</li></ul></li><li>当其中一个链表遍历完后，将另一个链表的剩余部分直接接到新链表的末尾。</li><li>返回哨兵节点的下一个节点，即新的头节点。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-comment">// 创建哨兵节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br><br>        <span class="hljs-comment">// 同时遍历两个链表</span><br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>                pre.next = list1;<br>                list1 = list1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre.next = list2;<br>                list2 = list2.next;<br>            &#125;<br>            pre = pre.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 将剩余的链表部分接到新链表的末尾</span><br>        pre.next = (list1 == <span class="hljs-literal">null</span>) ? list2 : list1;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n + m)，其中 n 和 m 分别是两个链表的长度。我们需要遍历两个链表中的每个节点。</li><li><strong>空间复杂度</strong>: O(1)，我们只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用哨兵节点可以简化操作，避免处理头节点为空的特殊情况。</li><li>在比较节点值时，需要确保 <code>pre</code> 指向的是新链表的最新节点，并更新 <code>pre</code>。</li><li>在其中一个链表遍历完后，直接将另一个链表的剩余部分接到新链表末尾即可。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-2</title>
    <link href="/2024/07/28/hot100-2/"/>
    <url>/2024/07/28/hot100-2/</url>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">https://leetcode.cn/problems/longest-palindromic-substring/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题要求找到字符串中的最长回文子串。我们可以使用中心扩展法来解决这个问题。对于每个字符，我们尝试将其作为中心，向左右两侧扩展，检查扩展后形成的子串是否为回文。需要注意的是，回文子串的长度可以是奇数也可以是偶数，因此我们需要分别处理这两种情况。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化两个变量 len 和 index 分别记录最长回文子串的长度和起始位置。</li><li>遍历字符串中的每个字符，以当前字符为中心向左右扩展，检查形成的子串是否为回文。</li><li>对于每个字符，分别处理回文子串长度为奇数和偶数的情况。</li><li>在扩展过程中，如果发现更长的回文子串，更新 len 和 index。</li><li>最后，根据 index 和 len 返回最长回文子串。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长回文子串的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长回文子串的起始位置</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 处理奇数长度的回文子串</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>, right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最长回文子串的长度和起始位置</span><br>            <span class="hljs-keyword">if</span> (len &lt; right - left - <span class="hljs-number">1</span>) &#123;<br>                index = left + <span class="hljs-number">1</span>;<br>                len = right - left - <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 处理偶数长度的回文子串</span><br>            left = i;<br>            right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最长回文子串的长度和起始位置</span><br>            <span class="hljs-keyword">if</span> (len &lt; right - left - <span class="hljs-number">1</span>) &#123;<br>                index = left + <span class="hljs-number">1</span>;<br>                len = right - left - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回最长回文子串</span><br>        <span class="hljs-keyword">return</span> s.substring(index, len + index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n^2)，其中 n 是字符串的长度。中心扩展法的每次扩展操作在最坏情况下需要遍历整个字符串，因此总时间复杂度为 O(n^2)。</li><li><strong>空间复杂度</strong>：O(1)，我们只使用了常数空间来存储变量。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要分别处理回文子串长度为奇数和偶数的情况。</li><li>确保在每次扩展后更新最长回文子串的长度和起始位置。</li><li>在进行字符串截取时，注意索引的正确计算，避免越界。</li></ul><h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h1><p><a href="https://leetcode.cn/problems/regular-expression-matching/description/">https://leetcode.cn/problems/regular-expression-matching/description/</a></p><h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><p><a href="https://leetcode.cn/problems/container-with-most-water/description/">https://leetcode.cn/problems/container-with-most-water/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题的目标是找到两个线段，使它们与 x 轴形成的容器能够容纳最多的水。我们可以使用双指针方法，从两端向中间靠拢，以此找到最大面积。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化两个指针 <code>left</code> 和 <code>right</code> 分别指向数组的左右两端，以及变量 <code>ans</code> 来存储最大面积。</li><li>使用一个 <code>while</code> 循环，当 <code>left</code> 小于 <code>right</code> 时，进行以下操作：<ul><li>计算当前容器的面积，面积的高度是 <code>height[left]</code> 和 <code>height[right]</code> 中的较小值，宽度是 <code>right - left</code>。</li><li>更新最大面积 <code>ans</code>。</li><li>如果 <code>height[left]</code> 小于 <code>height[right]</code>，移动左指针 <code>left</code> 向右一步，否则移动右指针 <code>right</code> 向左一步。</li></ul></li><li>返回 <code>ans</code> 作为结果。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 初始化最大面积为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 使用双指针，一头一尾</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>; <br>        <br>        <span class="hljs-comment">// 双指针向中间移动</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 计算当前容器的面积，并更新最大面积</span><br>            ans = Math.max((right - left) * Math.min(height[left], height[right]), ans);<br>            <br>            <span class="hljs-comment">// 移动较矮的那条边的指针</span><br>            <span class="hljs-keyword">if</span> (height[left] &gt; height[right]) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是数组的长度。每个元素最多被访问一次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>双指针方法利用了贪心策略：总是尝试通过移动较矮的边来找到更大的容器。</li><li>如果两个指针指向的高度相等，任意移动一个指针都可以。</li></ul><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><p><a href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了找到所有和为0的三元组，我们可以使用排序和双指针方法。具体步骤如下：</p><ol><li>首先对数组进行排序，这样我们可以使用双指针来查找三元组。</li><li>遍历排序后的数组，对于每个元素 <code>nums[i]</code>，使用双指针 <code>left</code> 和 <code>right</code> 在其后的子数组中寻找两个数，使它们的和为 <code>-nums[i]</code>。</li><li>为了避免重复的三元组，我们需要跳过相同的元素。</li></ol><h3 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>对数组进行排序。</li><li>初始化结果列表 <code>ans</code>。</li><li>遍历数组，对于每个元素 <code>nums[i]</code>：<ul><li>如果当前元素与前一个元素相同，跳过，避免重复的三元组。</li><li>使用双指针 <code>left</code> 和 <code>right</code> 分别指向 <code>i+1</code> 和数组末尾。</li><li>计算三数之和 <code>sum = nums[i] + nums[left] + nums[right]</code>。</li><li>如果 <code>sum == 0</code>，将三元组加入结果列表，并移动指针，跳过重复元素。</li><li>如果 <code>sum &lt; 0</code>，移动左指针 <code>left</code> 向右一步。</li><li>如果 <code>sum &gt; 0</code>，移动右指针 <code>right</code> 向左一步。</li></ul></li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 初始化结果列表</span><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 对数组进行排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 跳过重复元素</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 初始化双指针</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 找到一个三元组</span><br>                    ans.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 跳过重复元素</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;<br>                        left++;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-comment">// 移动指针</span><br>                    left++;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n^2)，其中 n 是数组的长度。排序的时间复杂度为 O(n log n)，遍历数组的时间复杂度为 O(n^2)。</li><li><strong>空间复杂度</strong>: O(1)，不考虑结果列表的空间，使用了常数级别的额外空间。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>为了避免重复的三元组，遍历数组时需要跳过相同的元素。</li><li>在寻找三元组的过程中，双指针也需要跳过重复的元素。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-1</title>
    <link href="/2024/07/26/hot100-1/"/>
    <url>/2024/07/26/hot100-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/description/">https://leetcode.cn/problems/two-sum/description/</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用哈希表存储数组中每个元素的值及其对应的索引。</li><li>在遍历数组的过程中，计算目标值与当前元素的差值。</li><li>检查哈希表中是否存在这个差值。<ul><li>如果存在，则找到了两个数，返回它们的索引。</li><li>如果不存在，将当前元素及其索引存入哈希表。</li></ul></li></ol><p>这种方法只需遍历数组一次，时间复杂度为 O(n)，空间复杂度也为 O(n)。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 创建一个哈希表来存储数值和对应的索引</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> target - nums[i];<br>            <br>            <span class="hljs-comment">// 如果哈希表中存在目标值减去当前值的结果，则返回对应的索引</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(tmp)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(tmp), i&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则，将当前值和索引放入哈希表</span><br>                map.put(nums[i], i);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果没有找到合适的数对，返回空数组（可以根据需求修改）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p><strong>时间复杂度</strong>：O(n)</p><ul><li>因为只需要遍历数组一次，每次查找哈希表的复杂度为 O(1)，总时间复杂度为 O(n)。</li></ul></li><li><p><strong>空间复杂度</strong>：O(n)</p><ul><li>在最坏情况下，哈希表中存储了 n 个元素，因此空间复杂度为 O(n)。</li></ul></li></ul><br><br><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><p><a href="https://leetcode.cn/problems/add-two-numbers/description/">https://leetcode.cn/problems/add-two-numbers/description/</a></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>创建一个虚拟头节点 <code>dummy</code> 以便于处理结果链表。</li><li>使用指针 <code>pre</code> 指向当前处理的节点，初始化为 <code>dummy</code>。</li><li>初始化进位 <code>carry</code> 为 0。</li><li>遍历两个链表，直到都为空：<ul><li>取出当前节点的值 <code>x</code> 和 <code>y</code>，如果链表已经结束则为 0。</li><li>计算当前位的和 <code>sum = x + y + carry</code>。</li><li>更新进位 <code>carry = sum / 10</code>。</li><li>当前位的值为 <code>sum % 10</code>。</li><li>将当前节点的结果添加到结果链表中。</li><li>移动指针到下一个节点。</li></ul></li><li>最后，如果还有进位，添加到结果链表中。</li><li>返回结果链表的下一个节点，即 <code>dummy.next</code>。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (l1 != <span class="hljs-literal">null</span>) ? l1.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (l2 != <span class="hljs-literal">null</span>) ? l2.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y + carry;<br><br>            carry = sum / <span class="hljs-number">10</span>;<br>            sum = sum % <span class="hljs-number">10</span>;<br><br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            pre = pre.next;<br><br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) l2 = l2.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理最高位的进位</span><br>        <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是较长链表的长度。需要遍历一次每个节点。</li><li><strong>空间复杂度</strong>：O(n)，用于存储结果链表。</li></ul><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题可以使用滑动窗口的技巧来解决。我们维护一个窗口，并使用两个指针（left 和 right）来标记窗口的左右边界。同时使用一个哈希集合（Set）来存储当前窗口内的字符。随着右指针的移动，我们检查字符是否重复，如果重复则移动左指针以缩小窗口，直到窗口内没有重复字符为止。在这个过程中，我们记录并更新最长的无重复字符子串的长度。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个哈希集合（Set）用于存储当前窗口内的字符。</li><li>初始化两个指针 left 和 right，均指向字符串的起始位置。</li><li>初始化一个变量 ans 来记录最长无重复字符子串的长度。</li><li>遍历字符串，移动右指针，并检查当前字符是否在哈希集合中。</li><li>如果当前字符不在集合中，则将其加入集合，并继续移动右指针。</li><li>如果当前字符在集合中，则更新最长长度，并移动左指针，直到窗口内不再包含重复字符。</li><li>重复步骤4-6，直到右指针遍历完整个字符串。</li><li>返回 ans 作为结果。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 使用哈希集合来存储当前窗口内的字符</span><br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 滑动窗口的左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录最长无重复字符子串的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>            <span class="hljs-type">Character</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-keyword">if</span>(set.contains(c))&#123;<br>                <span class="hljs-comment">// 更新最长长度</span><br>                ans = Math.max(ans, right - left);<br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-comment">// 移动左指针，直到窗口内不再包含重复字符</span><br>                    <span class="hljs-keyword">if</span>(s.charAt(left) == c)&#123;<br>                        left++;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    set.remove(s.charAt(left));<br>                    left++;<br>                &#125;<br>            &#125;<br>            set.add(c);<br>            right++;<br>        &#125;<br>        <span class="hljs-comment">// 最后一次更新最长长度</span><br>        ans = Math.max(ans, right - left);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是字符串的长度。每个字符在滑动窗口中最多被访问两次（一次通过右指针，一次通过左指针）。</li><li><strong>空间复杂度</strong>：O(min(n, m))，其中 n 是字符串的长度，m 是字符集的大小。在最坏情况下，字符串中的所有字符都不同，因此哈希集合需要存储所有字符。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要特别注意处理边界情况，例如空字符串的输入。</li><li>在计算最长长度时，要确保在循环结束后再进行一次更新，以处理窗口移动到字符串末尾的情况。</li></ul><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h1><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">https://leetcode.cn/problems/median-of-two-sorted-arrays/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。算法的时间复杂度应该为 O(log (m+n))。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题要求时间复杂度为 O(log (m+n))，提示我们可以使用二分查找的方法。我们通过在较短的数组上进行二分查找，找到一个划分，使得左半部分和右半部分的元素个数相等，并且左半部分的最大值小于等于右半部分的最小值。根据这个划分点，我们可以计算出中位数。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>确保 nums1 是较短的数组，以简化后续逻辑。</li><li>初始化两个指针 left 和 right 分别指向 nums1 的左右边界。</li><li>使用二分查找，计算 nums1 和 nums2 的划分点 m1 和 m2。</li><li>检查划分是否符合条件：nums1[m1] &gt;&#x3D; nums2[m2 - 1] 且 nums1[m1 - 1] &lt;&#x3D; nums2[m2]。</li><li>如果条件不满足，根据情况调整 left 或 right 指针，缩小搜索范围。</li><li>计算最终的中位数，根据总长度的奇偶性返回结果。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-comment">// 确保 nums1 是较短的数组</span><br>        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length) &#123;<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 二分查找的中点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-comment">// 计算 nums2 的划分点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - m1;<br><br>            <span class="hljs-comment">// nums1 的划分点过小，增大 left</span><br>            <span class="hljs-keyword">if</span> (m1 &lt; m &amp;&amp; nums1[m1] &lt; nums2[m2 - <span class="hljs-number">1</span>]) &#123;<br>                left = m1 + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// nums1 的划分点过大，减小 right</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m1 &gt; <span class="hljs-number">0</span> &amp;&amp; nums1[m1 - <span class="hljs-number">1</span>] &gt; nums2[m2]) &#123;<br>                right = m1 - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 找到合适的划分点</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> maxleft;<br>                <span class="hljs-comment">// 处理边界情况</span><br>                <span class="hljs-keyword">if</span> (m1 == <span class="hljs-number">0</span>) &#123;<br>                    maxleft = nums2[m2 - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == <span class="hljs-number">0</span>) &#123;<br>                    maxleft = nums1[m1 - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    maxleft = Math.max(nums1[m1 - <span class="hljs-number">1</span>], nums2[m2 - <span class="hljs-number">1</span>]);<br>                &#125;<br><br>                <span class="hljs-comment">// 总长度为奇数，中位数为 maxleft</span><br>                <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> maxleft;<br>                &#125;<br><br>                <span class="hljs-type">int</span> minright;<br>                <span class="hljs-comment">// 处理边界情况</span><br>                <span class="hljs-keyword">if</span> (m1 == m) &#123;<br>                    minright = nums2[m2];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == n) &#123;<br>                    minright = nums1[m1];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    minright = Math.min(nums1[m1], nums2[m2]);<br>                &#125;<br><br>                <span class="hljs-comment">// 总长度为偶数，中位数为 maxleft 和 minright 的平均值</span><br>                <span class="hljs-keyword">return</span> (maxleft + minright) / <span class="hljs-number">2.0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(log(min(m, n)))，其中 m 和 n 分别是两个数组的长度。因为我们在较短的数组上进行二分查找。</li><li><strong>空间复杂度</strong>：O(1)，我们只使用了常数空间来存储变量。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保 nums1 是较短的数组，可以简化边界条件的处理。</li><li>处理边界情况时，确保划分点在数组范围内，避免数组越界。</li><li>总长度为奇数和偶数的情况需要分别处理。</li></ul><h4 id="为什么从较短的数组开始"><a href="#为什么从较短的数组开始" class="headerlink" title="为什么从较短的数组开始"></a>为什么从较短的数组开始</h4><p>减少边界情况：当我们在较短的数组上进行二分查找时，我们只需要考虑较短数组的长度，这样划分点的计算和调整会更加简单。如果我们在较长的数组上进行二分查找，划分点可能会落在较长数组的边界附近，增加处理复杂性。</p><p>避免数组越界：在二分查找过程中，我们需要根据划分点计算两个数组的左半部分和右半部分。如果我们在较短的数组上进行二分查找，更容易确保划分点在数组范围内，避免数组越界。</p><p>优化性能：在较短的数组上进行二分查找，能够更快地收敛到正确的划分点。因为较短数组的长度更小，二分查找的迭代次数也会相应减少，从而提高性能。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>themes</title>
    <link href="/2024/07/26/themes/"/>
    <url>/2024/07/26/themes/</url>
    
    <content type="html"><![CDATA[<h1 id="fluid"><a href="#fluid" class="headerlink" title="fluid"></a>fluid</h1><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p><img src="/2024/07/26/themes/fluid.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>themes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learn_markdown</title>
    <link href="/2024/07/23/learn-markdown/"/>
    <url>/2024/07/23/learn-markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>使用#的数量定义标题的级别，#后面与标题之间有一个空格</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><h6 id="6"><a href="#6" class="headerlink" title="6"></a>6</h6><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>段落与段落之间用空白行分割</p><p>我看见他戴着黑布小帽，穿着黑布大马褂，深青布棉袍，蹒跚地走到铁道边，慢慢探身下去，尚不大难。可是他穿过铁道，要爬上那边月台，就不容易了。他用两手攀着上面，两脚再向上缩；他肥胖的身子向左微倾，显出努力的样子。这时我看见他的背影，我的泪很快地流下来了。我赶紧拭干了泪，怕他看见，也怕别人看见。我再向外看时，他已抱了朱红的橘子望回走了。过铁道时，他先将橘子散放在地上，自己慢慢爬下，再抱起橘子走。到这边时，我赶紧去搀他。他和我走到车上，将橘子一股脑儿放在我的皮大衣上。于是扑扑衣上的泥土，心里很轻松似的，过一会说，“我走了；到那边来信！”我望着他走出去。他走了几步，回过头看见我，说，“进去吧，里边没人。”等他的背影混入来来往往的人里，再找不着了，我便进来坐下，我的眼泪又来了。 — 摘自朱自清的《背影》</p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>静夜思<br>李白<br>床前明月光，疑是地上霜。<br>举头望明月，低头思故乡。</p><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>你__好__   <strong>你好</strong><br><strong>hello</strong> hello<br>你也<strong>好</strong></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p><em>斜体</em><br>_斜体<br>xie<em>斜体</em>ti</p><h3 id="粗体加斜体"><a href="#粗体加斜体" class="headerlink" title="粗体加斜体"></a>粗体加斜体</h3><p><em><strong>粗体斜体</strong></em></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>sssssssss<br>ssssssss<br>ssssss  </p></blockquote><blockquote><p>sdsdsdsd</p></blockquote><p>段落 + 引用</p><blockquote><p>sdsdsdsd</p><p>sdsdsdsd</p></blockquote><p>嵌套块引用</p><blockquote><p>ss</p><blockquote><p>ss</p><blockquote><p>ss</p><blockquote><p>ss</p></blockquote></blockquote></blockquote><p>s</p></blockquote><p>引用 + 其他</p><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h1 id="images"><a href="#images" class="headerlink" title="images"></a>images</h1><p>图片放置格式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[]</span>(png.jpg)<br></code></pre></td></tr></table></figure><p><img src="/2024/07/23/learn-markdown/pdx1.jpg"></p><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="hljs-variable">$a</span><span class="hljs-keyword">^2</span><span class="language-xml"> + b</span><span class="hljs-keyword">^2</span><span class="language-xml"> = c</span><span class="hljs-keyword">^2</span><span class="language-xml">$</span><br></code></pre></td></tr></table></figure><p>$a^2 + b^2 &#x3D; c^2$</p><h2 id="块级公式"><a href="#块级公式" class="headerlink" title="块级公式"></a>块级公式</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span> = c^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>a^2 + b^2 &#x3D; c^2<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
