<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hot100-5</title>
    <link href="/2024/07/30/hot100-5/"/>
    <url>/2024/07/30/hot100-5/</url>
    
    <content type="html"><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">https://leetcode.cn/problems/search-in-rotated-sorted-array/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值互不相同。在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（0 &lt;&#x3D; k &lt; nums.length）上进行了旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标从 0 开始计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>。</p><p>给你旋转后的数组 <code>nums</code> 和一个整数 <code>target</code>，如果 <code>nums</code> 中存在这个目标值 <code>target</code>，则返回它的下标，否则返回 -1。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用二分查找算法来解决这个问题。通过二分查找，我们可以在 O(log n) 的时间复杂度内找到目标值。在旋转数组中，至少有一半是有序的，通过判断哪一半有序，可以确定目标值是否在有序部分，从而决定搜索的范围。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化两个指针 <code>left</code> 和 <code>right</code>，分别指向数组的左右两端。</li><li>进行二分查找，直到 <code>left</code> 超过 <code>right</code>：<ul><li>计算中间位置 <code>mid</code>。</li><li>如果 <code>nums[mid]</code> 等于目标值 <code>target</code>，直接返回 <code>mid</code>。</li><li>判断哪一半是有序的：<ul><li>如果 <code>nums[mid]</code> 到 <code>nums[right]</code> 是有序的：<ul><li>判断目标值 <code>target</code> 是否在这个有序范围内：<ul><li>如果是，则继续在右半部分进行二分查找。</li><li>否则，在左半部分进行二分查找。</li></ul></li></ul></li><li>如果 <code>nums[left]</code> 到 <code>nums[mid]</code> 是有序的：<ul><li>判断目标值 <code>target</code> 是否在这个有序范围内：<ul><li>如果是，则继续在左半部分进行二分查找。</li><li>否则，在右半部分进行二分查找。</li></ul></li></ul></li></ul></li></ul></li><li>如果没有找到目标值，返回 -1。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 初始化左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 二分查找</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br><br>            <span class="hljs-comment">// 如果中间值等于目标值，返回中间值的索引</span><br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断哪一半是有序的</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[right]) &#123;<br>                <span class="hljs-comment">// 右半部分有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<br>                    left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 在右半部分查找</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 在左半部分查找</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 左半部分有序</span><br>                <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                    right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 在左半部分查找</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 在右半部分查找</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果没有找到目标值，返回 -1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(log n)，因为使用了二分查找算法。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>要特别注意边界条件的判断，确保二分查找的范围正确。</li><li>判断哪一半是有序的，可以通过比较 <code>nums[mid]</code> 与 <code>nums[right]</code> 或 <code>nums[mid]</code> 与 <code>nums[left]</code> 来进行。</li><li>处理旋转数组的关键是利用二分查找的特性，通过判断哪一半是有序的来缩小查找范围。</li></ul><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用二分查找来找到目标值在数组中的开始位置和结束位置。首先，我们需要找到目标值的左边界，然后再找到右边界。</p><ol><li><p>使用二分查找找到目标值的左边界：</p><ul><li>初始化 <code>left</code> 为 0，<code>right</code> 为数组长度。</li><li>在循环中，计算中间位置 <code>mid</code>。</li><li>如果 <code>nums[mid]</code> 小于目标值 <code>target</code>，则将 <code>left</code> 移动到 <code>mid + 1</code>。</li><li>否则，将 <code>right</code> 移动到 <code>mid</code>。</li><li>循环结束后，如果 <code>nums[left]</code> 不等于 <code>target</code>，说明数组中不存在目标值，返回 <code>[-1, -1]</code>。</li><li>否则，记录左边界位置。</li></ul></li><li><p>使用二分查找找到目标值的右边界：</p><ul><li>初始化 <code>right</code> 为数组长度。</li><li>在循环中，计算中间位置 <code>mid</code>。</li><li>如果 <code>nums[mid]</code> 小于等于目标值 <code>target</code>，则将 <code>left</code> 移动到 <code>mid + 1</code>。</li><li>否则，将 <code>right</code> 移动到 <code>mid</code>。</li><li>循环结束后，记录右边界位置为 <code>right - 1</code>。</li></ul></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 初始化结果数组</span><br>        <span class="hljs-type">int</span>[] ans = &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-comment">// 边界条件处理</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span> || nums[<span class="hljs-number">0</span>] &gt; target || nums[nums.length - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">return</span> ans;<br><br>        <span class="hljs-comment">// 二分查找左边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查左边界是否存在目标值</span><br>        <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target) <span class="hljs-keyword">return</span> ans;<br>        ans[<span class="hljs-number">0</span>] = left;<br><br>        <span class="hljs-comment">// 二分查找右边界</span><br>        right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        ans[<span class="hljs-number">1</span>] = right - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(log n)，其中 n 是数组的长度。二分查找的时间复杂度为 O(log n)。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>二分查找的左右边界初始化为数组的开始和结束位置。</li><li>找左边界时，确保找到的第一个等于目标值的索引。</li><li>找右边界时，确保找到的最后一个等于目标值的索引。</li><li>检查左边界是否存在目标值，以避免数组中不存在目标值时返回错误结果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-4</title>
    <link href="/2024/07/30/hot100-4/"/>
    <url>/2024/07/30/hot100-4/</url>
    
    <content type="html"><![CDATA[<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h1><p><a href="https://leetcode.cn/problems/generate-parentheses/description/">https://leetcode.cn/problems/generate-parentheses/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于生成所有可能的并且有效的括号组合。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来生成所有可能的括号组合。在构建括号组合的过程中，我们需要确保生成的括号序列始终有效。具体来说，任意前缀中左括号的数量必须大于或等于右括号的数量。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个结果列表 <code>ans</code> 用于存储所有有效的括号组合，并使用一个 <code>StringBuilder</code> 对象 <code>sb</code> 来构建当前的括号序列。</li><li>定义一个回溯函数 <code>backtracking</code>，它接受两个参数：剩余的左括号数量 <code>left</code> 和剩余的右括号数量 <code>right</code>。</li><li>在回溯函数中：<ul><li>如果左右括号数量都为0，说明当前构建的括号序列是有效的，将其加入结果列表 <code>ans</code> 中。</li><li>如果还有左括号可以使用，则添加一个左括号，并递归调用回溯函数。</li><li>如果右括号数量大于左括号数量，则添加一个右括号，并递归调用回溯函数。</li><li>在递归返回之前，撤销上一步的选择，即从 <code>sb</code> 中删除最后一个字符。</li></ul></li><li>调用回溯函数开始生成所有可能的括号组合。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 结果列表</span><br>    List&lt;String&gt; ans;<br>    <span class="hljs-comment">// 用于构建当前括号序列</span><br>    StringBuilder sb;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 初始化结果列表</span><br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始化 StringBuilder</span><br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// 开始回溯</span><br>        backtracking(n, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 如果左右括号数量都为 0，添加当前序列到结果列表</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>            ans.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果还有左括号可以使用，添加一个左括号并递归</span><br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            backtracking(left - <span class="hljs-number">1</span>, right);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果右括号数量大于左括号数量，添加一个右括号并递归</span><br>        <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; left &lt; right) &#123;<br>            sb.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            backtracking(left, right - <span class="hljs-number">1</span>);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(4^n &#x2F; √n)，生成所有可能的括号组合数量为卡特兰数，这里的时间复杂度是卡特兰数的上界。</li><li><strong>空间复杂度</strong>: O(n)，递归的深度最大为 <code>2n</code>，每次递归调用使用的空间为 O(1)。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在构建括号序列时，必须确保右括号的数量始终不大于左括号的数量。</li><li>使用 <code>StringBuilder</code> 来构建当前的括号序列，避免多次字符串拼接的开销。</li><li>在递归返回之前，撤销上一步的选择，以确保构建其他可能的组合时不受影响。</li></ul><h1 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a>23. 合并 K 个升序链表</h1><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">https://leetcode.cn/problems/merge-k-sorted-lists/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用最小堆（优先队列）来合并 <code>k</code> 个已排序的链表。最小堆能够在 O(log k) 的时间复杂度内获取和删除最小元素，使我们可以高效地找到所有链表中当前最小的节点。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个最小堆 <code>PriorityQueue</code>，用来存储每个链表的节点。堆的大小为 <code>k</code>。</li><li>将每个链表的第一个节点加入最小堆。</li><li>创建一个哨兵节点 <code>dummy</code> 作为合并后链表的头节点，并初始化一个指针 <code>pre</code> 指向哨兵节点。</li><li>不断从最小堆中取出当前最小的节点，将其加入合并后的链表中，并将指针 <code>pre</code> 移动到新加入的节点。</li><li>如果被取出的节点还有下一个节点，则将下一个节点加入最小堆。</li><li>当最小堆为空时，合并完成，返回哨兵节点的下一个节点作为合并后的链表的头节点。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-comment">// 如果链表数组为空或长度为0，直接返回null</span><br>        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 创建一个长度为k的最小堆</span><br>        PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(lists.length, (a, b) -&gt; Integer.compare(a.val, b.val));<br><br>        <span class="hljs-comment">// 将每个链表的第一个节点加入最小堆</span><br>        <span class="hljs-keyword">for</span> (ListNode list : lists) &#123;<br>            <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span>) &#123;<br>                pq.offer(list);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建哨兵节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br><br>        <span class="hljs-comment">// 不断从最小堆中取出当前最小的节点，将其加入合并后的链表中</span><br>        <span class="hljs-keyword">while</span> (pq.peek() != <span class="hljs-literal">null</span>) &#123;<br>            pre.next = pq.poll();<br>            pre = pre.next;<br>            <span class="hljs-comment">// 如果被取出的节点还有下一个节点，将下一个节点加入最小堆</span><br>            <span class="hljs-keyword">if</span> (pre.next != <span class="hljs-literal">null</span>) &#123;<br>                pq.offer(pre.next);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回哨兵节点的下一个节点作为合并后的链表的头节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(N log k)，其中 N 是所有链表中节点的总数，k 是链表的数量。每次插入和删除操作的时间复杂度为 O(log k)，总共进行 N 次操作。</li><li><strong>空间复杂度</strong>: O(k)，用于存储最小堆中最多 k 个节点。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要处理输入为空或长度为 0 的情况，直接返回 null。</li><li>使用最小堆可以高效地合并多个已排序的链表，每次操作的时间复杂度为 O(log k)。</li><li>哨兵节点可以简化链表操作，避免处理头节点为空的特殊情况。</li></ul><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><p><a href="https://leetcode.cn/problems/next-permutation/description/">https://leetcode.cn/problems/next-permutation/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>整数数组的一个排列就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr &#x3D; [1,2,3]，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]。<br>整数数组的下一个排列是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的下一个排列就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2]。类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2]。而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3]，因为 [3,2,1] 不存在一个字典序更大的排列。</p><p>给你一个整数数组 <code>nums</code>，找出 <code>nums</code> 的下一个排列。必须原地修改，只允许使用额外常数空间。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>要找到下一个字典序更大的排列，我们可以按以下步骤操作：</p><ol><li>从后向前查找第一个相邻升序对 <code>(i-1, i)</code>，满足 <code>nums[i-1] &lt; nums[i]</code>。这样可以确定需要调整的部分。</li><li>在从右往左找到的第一个升序对中，找出右侧部分中比 <code>nums[i-1]</code> 大的最小元素，并交换它们。</li><li>将右侧部分从 <code>i</code> 开始的元素逆序排列，以得到最小的字典序。</li></ol><h3 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>从数组末尾向前查找第一个 <code>nums[i-1] &lt; nums[i]</code> 的位置 <code>i-1</code>。</li><li>如果找到了这样的 <code>i-1</code>，则在 <code>i</code> 到末尾之间查找比 <code>nums[i-1]</code> 大的最小元素 <code>nums[j]</code>，交换 <code>nums[i-1]</code> 和 <code>nums[j]</code>。</li><li>将位置 <code>i</code> 到末尾的部分进行反转，使其变成最小字典序。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 特殊情况处理</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br><br>        <span class="hljs-comment">// 从后向前查找第一个升序对</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果找到了升序对</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 从后向前找比 nums[i] 大的最小元素</span><br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span> (j = len - <span class="hljs-number">1</span>; j &gt; i; j--) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 交换 nums[i] 和 nums[j]</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = tmp;<br>        &#125;<br><br>        <span class="hljs-comment">// 反转 i 之后的部分</span><br>        reverse(nums, i + <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[start];<br>            nums[start] = nums[end];<br>            nums[end] = tmp;<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是数组的长度。最坏情况下需要遍历数组三次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>从后向前查找第一个升序对 <code>(i-1, i)</code>，确保找到的调整位置是字典序最小的。</li><li>交换元素时，确保选择的是比 <code>nums[i-1]</code> 大的最小元素，以获得下一个更大的排列。</li><li>最后一步的反转操作是为了将调整位置后的部分变成最小字典序，从而确保整体排列是下一个字典序更大的排列。</li></ul><h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h1><p><a href="https://leetcode.cn/problems/longest-valid-parentheses/description/">https://leetcode.cn/problems/longest-valid-parentheses/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划的方法来解决这个问题。我们定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以索引 <code>i</code> 结尾的最长有效括号子串的长度。</p><h3 id="详细步骤-3"><a href="#详细步骤-3" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个 <code>dp</code> 数组，长度与字符串 <code>s</code> 相同，初始值都为 0。</li><li>遍历字符串 <code>s</code>，从索引 1 开始：<ul><li>如果 <code>s[i]</code> 是 ‘)’ 并且前一个字符 <code>s[i-1]</code> 是 ‘(‘，则我们找到了一对有效括号：<ul><li><code>dp[i] = dp[i-2] + 2</code>，这里 <code>dp[i-2]</code> 是在当前这对有效括号之前的最长有效括号子串的长度。</li></ul></li><li>如果 <code>s[i]</code> 是 ‘)’ 并且前一个字符 <code>s[i-1]</code> 是 ‘)’，则我们需要检查 <code>s[i-dp[i-1]-1]</code> 是否是 ‘(‘：<ul><li>如果是，则 <code>dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2</code>，其中 <code>dp[i-1]</code> 是前一个位置的最长有效括号子串长度，<code>dp[i-dp[i-1]-2]</code> 是在当前有效子串之前的最长有效括号子串的长度。</li></ul></li></ul></li><li>更新 <code>maxLength</code> 为 <code>dp[i]</code> 中的最大值。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 初始化最大长度为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 动态规划数组</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br><br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 如果当前字符是&#x27;)&#x27;</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 检查前一个字符是否是&#x27;(&#x27;</span><br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <br>                <span class="hljs-comment">// 如果前一个字符是&#x27;)&#x27;，并且在前一个有效括号子串之前有一个&#x27;(&#x27;</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + ((i - dp[i - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-comment">// 更新最大长度</span><br>                maxLength = Math.max(maxLength, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是字符串的长度。我们只需遍历字符串一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储动态规划数组 <code>dp</code>。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>动态规划数组 <code>dp</code> 用于存储以每个索引结尾的最长有效括号子串的长度。</li><li>在计算 <code>dp[i]</code> 时，需要根据当前字符和前一个字符的不同情况进行不同的处理。</li><li><code>maxLength</code> 记录了遍历过程中找到的最长有效括号子串的长度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-3</title>
    <link href="/2024/07/30/hot100-3/"/>
    <url>/2024/07/30/hot100-3/</url>
    
    <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来解决这个问题。回溯算法能够在构建解决方案的过程中动态地撤销已经做出的选择，从而可以探索所有可能的组合。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个映射数组 <code>lettermap</code>，将数字与其对应的字母关联起来。</li><li>初始化结果列表 <code>ans</code> 和一个用于构建组合的 <code>StringBuilder</code> 对象 <code>sb</code>。</li><li>如果输入的字符串为空，直接返回空列表。</li><li>使用回溯函数 <code>backtracking</code> 来生成所有可能的组合：<ul><li>如果当前索引等于输入字符串的长度，表示已经生成了一个完整的组合，将其加入结果列表。</li><li>否则，获取当前数字对应的字母集，然后依次尝试每个字母，并递归调用 <code>backtracking</code> 生成下一层的组合。</li><li>在递归返回之前，撤销上一步的选择，即从 <code>sb</code> 中删除最后一个字符。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] lettermap =&#123;<br>        <span class="hljs-string">&quot; &quot;</span>,    <span class="hljs-comment">// 0</span><br>        <span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// 1</span><br>        <span class="hljs-string">&quot;abc&quot;</span>,  <span class="hljs-comment">// 2</span><br>        <span class="hljs-string">&quot;def&quot;</span>,  <span class="hljs-comment">// 3</span><br>        <span class="hljs-string">&quot;ghi&quot;</span>,  <span class="hljs-comment">// 4</span><br>        <span class="hljs-string">&quot;jkl&quot;</span>,  <span class="hljs-comment">// 5</span><br>        <span class="hljs-string">&quot;mno&quot;</span>,  <span class="hljs-comment">// 6</span><br>        <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>        <span class="hljs-string">&quot;tuv&quot;</span>,  <span class="hljs-comment">// 8</span><br>        <span class="hljs-string">&quot;wxyz&quot;</span>  <span class="hljs-comment">// 9</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> StringBuilder sb;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; ans;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-comment">// 如果输入为空，返回空列表</span><br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始化结果列表和 StringBuilder</span><br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// 开始回溯</span><br>        backtracking(<span class="hljs-number">0</span>, digits);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> startIndex, String digits)</span> &#123;<br>        <span class="hljs-comment">// 如果当前索引等于输入字符串的长度，添加组合到结果列表</span><br>        <span class="hljs-keyword">if</span> (startIndex == digits.length()) &#123;<br>            ans.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获取当前数字对应的字母集</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> digits.charAt(startIndex) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lettermap[tmp].length(); i++) &#123;<br>            <span class="hljs-comment">// 选择一个字母</span><br>            sb.append(lettermap[tmp].charAt(i));<br>            <span class="hljs-comment">// 递归生成下一层的组合</span><br>            backtracking(startIndex + <span class="hljs-number">1</span>, digits);<br>            <span class="hljs-comment">// 撤销上一步选择</span><br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(3^n * 4^m)，其中 n 是对应 3 个字母的数字（如 2, 3, 4, 5, 6, 8）出现的次数，m 是对应 4 个字母的数字（如 7, 9）出现的次数。每次递归调用都会尝试所有可能的字母组合。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是输入字符串的长度。递归调用的深度最多为 n，另外需要 O(n) 的空间来存储临时的组合结果。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>回溯算法在生成组合时，先尝试一个字母，再递归生成下一个字母的组合，最终形成完整的字母组合。</li><li>使用 <code>StringBuilder</code> 来动态构建字符串，并在递归返回时撤销上一步的选择，可以有效减少字符串拼接的开销。</li><li>输入为空字符串时，直接返回空列表，避免不必要的计算。</li></ul><h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了删除链表的倒数第 <code>n</code> 个结点，我们可以使用快慢指针方法。</p><p>使用一个哨兵节点 <code>dummy</code>，指向链表的头节点。这样，即使删除头节点也能方便处理。<br>初始化两个指针 <code>slow</code> 和 <code>fast</code>，都指向哨兵节点。先让快指针 <code>fast</code> 走 <code>n</code> 步。然后同时移动快指针和慢指针，直到快指针到达链表的末尾。此时，慢指针 <code>slow</code> 的下一个节点就是要删除的节点。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个哨兵节点 <code>dummy</code>，并指向链表的头节点 <code>head</code>。</li><li>初始化两个指针 <code>slow</code> 和 <code>fast</code>，都指向哨兵节点 <code>dummy</code>。</li><li>让快指针 <code>fast</code> 先走 <code>n</code> 步。</li><li>继续同时移动 <code>slow</code> 和 <code>fast</code>，直到 <code>fast</code> 的下一个节点为空。</li><li>此时，<code>slow</code> 的下一个节点就是要删除的节点，将 <code>slow</code> 的下一个节点指向其下下个节点。</li><li>返回 <code>dummy</code> 的下一个节点作为新的头节点。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 创建哨兵节点并指向头节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-comment">// 初始化快慢指针</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy, fast = dummy;<br>        <br>        <span class="hljs-comment">// 快指针先走 n 步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 同时移动快慢指针，直到快指针到达链表末尾</span><br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 删除慢指针的下一个节点</span><br>        slow.next = slow.next.next;<br>        <br>        <span class="hljs-comment">// 返回新的头节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(L)，其中 L 是链表的长度。两个指针总共遍历了链表两次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用哨兵节点可以方便处理删除头节点的情况，避免单独处理这种特殊情况。</li><li>快指针先走 <code>n</code> 步，确保了在快指针到达链表末尾时，慢指针正好在需要删除的节点前一个位置。</li><li>如果链表为空或 <code>n</code> 超过链表长度，需要提前进行检查。</li></ul><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">https://leetcode.cn/problems/valid-parentheses/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 <code>s</code>，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了判断一个字符串中的括号是否有效，我们可以使用栈来辅助匹配括号。具体步骤如下：</p><ol><li>遍历字符串 <code>s</code> 中的每一个字符：<ul><li>如果是左括号，将其压入栈中。</li><li>如果是右括号，检查栈是否为空。如果栈为空，说明没有匹配的左括号，字符串无效。否则，弹出栈顶元素，并检查是否与当前右括号匹配。</li></ul></li><li>遍历完成后，如果栈为空，说明所有的左括号都匹配了相应的右括号，字符串有效。否则，字符串无效。</li></ol><h3 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个栈来存储左括号。</li><li>遍历字符串 <code>s</code>，对于每个字符：<ul><li>如果是左括号，将其压入栈中。</li><li>如果是右括号，检查栈是否为空。如果为空，返回 <code>false</code>。否则，弹出栈顶元素，并检查是否与当前右括号匹配。如果不匹配，返回 <code>false</code>。</li></ul></li><li>遍历完成后，检查栈是否为空。如果为空，返回 <code>true</code>，否则返回 <code>false</code>。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 栈用于存储左括号</span><br>        <span class="hljs-type">char</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[s.length()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历字符串中的每个字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-comment">// 如果是左括号，压入栈中</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                stack[top++] = c;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果是右括号，检查栈是否为空或栈顶是否匹配</span><br>                <span class="hljs-keyword">if</span> (top == <span class="hljs-number">0</span> || stack[top - <span class="hljs-number">1</span>] != getMatchingLeftBracket(c)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                top--; <span class="hljs-comment">// 匹配成功，弹出栈顶元素</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 栈为空，说明所有括号匹配成功</span><br>        <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回对应的左括号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getMatchingLeftBracket</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是字符串的长度。我们只遍历一次字符串。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是字符串的长度。最坏情况下栈中会存储所有的左括号。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>栈顶元素和当前右括号匹配时，弹出栈顶元素。</li><li>如果栈为空或栈顶元素不匹配，直接返回 <code>false</code>。</li><li>遍历结束后，检查栈是否为空，以判断所有的括号是否都匹配成功。</li></ul><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">https://leetcode.cn/problems/merge-two-sorted-lists/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了合并两个升序链表，我们可以使用双指针方法，同时遍历两个链表，将较小的节点依次加入到新的链表中。为了简化操作，我们可以使用一个哨兵节点来指向新链表的头节点。</p><h3 id="详细步骤-3"><a href="#详细步骤-3" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个哨兵节点 <code>dummy</code>，并初始化一个指针 <code>pre</code> 指向哨兵节点。</li><li>同时遍历两个链表 <code>list1</code> 和 <code>list2</code>：<ul><li>比较当前节点的值，将较小的节点加入到新链表中，并移动指针到下一个节点。</li><li>更新 <code>pre</code> 指向新链表的最新节点。</li></ul></li><li>当其中一个链表遍历完后，将另一个链表的剩余部分直接接到新链表的末尾。</li><li>返回哨兵节点的下一个节点，即新的头节点。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-comment">// 创建哨兵节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br><br>        <span class="hljs-comment">// 同时遍历两个链表</span><br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>                pre.next = list1;<br>                list1 = list1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre.next = list2;<br>                list2 = list2.next;<br>            &#125;<br>            pre = pre.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 将剩余的链表部分接到新链表的末尾</span><br>        pre.next = (list1 == <span class="hljs-literal">null</span>) ? list2 : list1;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n + m)，其中 n 和 m 分别是两个链表的长度。我们需要遍历两个链表中的每个节点。</li><li><strong>空间复杂度</strong>: O(1)，我们只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用哨兵节点可以简化操作，避免处理头节点为空的特殊情况。</li><li>在比较节点值时，需要确保 <code>pre</code> 指向的是新链表的最新节点，并更新 <code>pre</code>。</li><li>在其中一个链表遍历完后，直接将另一个链表的剩余部分接到新链表末尾即可。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-2</title>
    <link href="/2024/07/28/hot100-2/"/>
    <url>/2024/07/28/hot100-2/</url>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">https://leetcode.cn/problems/longest-palindromic-substring/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题要求找到字符串中的最长回文子串。我们可以使用中心扩展法来解决这个问题。对于每个字符，我们尝试将其作为中心，向左右两侧扩展，检查扩展后形成的子串是否为回文。需要注意的是，回文子串的长度可以是奇数也可以是偶数，因此我们需要分别处理这两种情况。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化两个变量 len 和 index 分别记录最长回文子串的长度和起始位置。</li><li>遍历字符串中的每个字符，以当前字符为中心向左右扩展，检查形成的子串是否为回文。</li><li>对于每个字符，分别处理回文子串长度为奇数和偶数的情况。</li><li>在扩展过程中，如果发现更长的回文子串，更新 len 和 index。</li><li>最后，根据 index 和 len 返回最长回文子串。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长回文子串的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长回文子串的起始位置</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 处理奇数长度的回文子串</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>, right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最长回文子串的长度和起始位置</span><br>            <span class="hljs-keyword">if</span> (len &lt; right - left - <span class="hljs-number">1</span>) &#123;<br>                index = left + <span class="hljs-number">1</span>;<br>                len = right - left - <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 处理偶数长度的回文子串</span><br>            left = i;<br>            right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最长回文子串的长度和起始位置</span><br>            <span class="hljs-keyword">if</span> (len &lt; right - left - <span class="hljs-number">1</span>) &#123;<br>                index = left + <span class="hljs-number">1</span>;<br>                len = right - left - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回最长回文子串</span><br>        <span class="hljs-keyword">return</span> s.substring(index, len + index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n^2)，其中 n 是字符串的长度。中心扩展法的每次扩展操作在最坏情况下需要遍历整个字符串，因此总时间复杂度为 O(n^2)。</li><li><strong>空间复杂度</strong>：O(1)，我们只使用了常数空间来存储变量。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要分别处理回文子串长度为奇数和偶数的情况。</li><li>确保在每次扩展后更新最长回文子串的长度和起始位置。</li><li>在进行字符串截取时，注意索引的正确计算，避免越界。</li></ul><h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h1><p><a href="https://leetcode.cn/problems/regular-expression-matching/description/">https://leetcode.cn/problems/regular-expression-matching/description/</a></p><h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><p><a href="https://leetcode.cn/problems/container-with-most-water/description/">https://leetcode.cn/problems/container-with-most-water/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题的目标是找到两个线段，使它们与 x 轴形成的容器能够容纳最多的水。我们可以使用双指针方法，从两端向中间靠拢，以此找到最大面积。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化两个指针 <code>left</code> 和 <code>right</code> 分别指向数组的左右两端，以及变量 <code>ans</code> 来存储最大面积。</li><li>使用一个 <code>while</code> 循环，当 <code>left</code> 小于 <code>right</code> 时，进行以下操作：<ul><li>计算当前容器的面积，面积的高度是 <code>height[left]</code> 和 <code>height[right]</code> 中的较小值，宽度是 <code>right - left</code>。</li><li>更新最大面积 <code>ans</code>。</li><li>如果 <code>height[left]</code> 小于 <code>height[right]</code>，移动左指针 <code>left</code> 向右一步，否则移动右指针 <code>right</code> 向左一步。</li></ul></li><li>返回 <code>ans</code> 作为结果。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 初始化最大面积为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 使用双指针，一头一尾</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>; <br>        <br>        <span class="hljs-comment">// 双指针向中间移动</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 计算当前容器的面积，并更新最大面积</span><br>            ans = Math.max((right - left) * Math.min(height[left], height[right]), ans);<br>            <br>            <span class="hljs-comment">// 移动较矮的那条边的指针</span><br>            <span class="hljs-keyword">if</span> (height[left] &gt; height[right]) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是数组的长度。每个元素最多被访问一次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>双指针方法利用了贪心策略：总是尝试通过移动较矮的边来找到更大的容器。</li><li>如果两个指针指向的高度相等，任意移动一个指针都可以。</li></ul><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><p><a href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了找到所有和为0的三元组，我们可以使用排序和双指针方法。具体步骤如下：</p><ol><li>首先对数组进行排序，这样我们可以使用双指针来查找三元组。</li><li>遍历排序后的数组，对于每个元素 <code>nums[i]</code>，使用双指针 <code>left</code> 和 <code>right</code> 在其后的子数组中寻找两个数，使它们的和为 <code>-nums[i]</code>。</li><li>为了避免重复的三元组，我们需要跳过相同的元素。</li></ol><h3 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>对数组进行排序。</li><li>初始化结果列表 <code>ans</code>。</li><li>遍历数组，对于每个元素 <code>nums[i]</code>：<ul><li>如果当前元素与前一个元素相同，跳过，避免重复的三元组。</li><li>使用双指针 <code>left</code> 和 <code>right</code> 分别指向 <code>i+1</code> 和数组末尾。</li><li>计算三数之和 <code>sum = nums[i] + nums[left] + nums[right]</code>。</li><li>如果 <code>sum == 0</code>，将三元组加入结果列表，并移动指针，跳过重复元素。</li><li>如果 <code>sum &lt; 0</code>，移动左指针 <code>left</code> 向右一步。</li><li>如果 <code>sum &gt; 0</code>，移动右指针 <code>right</code> 向左一步。</li></ul></li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 初始化结果列表</span><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 对数组进行排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 跳过重复元素</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 初始化双指针</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 找到一个三元组</span><br>                    ans.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 跳过重复元素</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;<br>                        left++;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-comment">// 移动指针</span><br>                    left++;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n^2)，其中 n 是数组的长度。排序的时间复杂度为 O(n log n)，遍历数组的时间复杂度为 O(n^2)。</li><li><strong>空间复杂度</strong>: O(1)，不考虑结果列表的空间，使用了常数级别的额外空间。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>为了避免重复的三元组，遍历数组时需要跳过相同的元素。</li><li>在寻找三元组的过程中，双指针也需要跳过重复的元素。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-1</title>
    <link href="/2024/07/26/hot100-1/"/>
    <url>/2024/07/26/hot100-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/description/">https://leetcode.cn/problems/two-sum/description/</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用哈希表存储数组中每个元素的值及其对应的索引。</li><li>在遍历数组的过程中，计算目标值与当前元素的差值。</li><li>检查哈希表中是否存在这个差值。<ul><li>如果存在，则找到了两个数，返回它们的索引。</li><li>如果不存在，将当前元素及其索引存入哈希表。</li></ul></li></ol><p>这种方法只需遍历数组一次，时间复杂度为 O(n)，空间复杂度也为 O(n)。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 创建一个哈希表来存储数值和对应的索引</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> target - nums[i];<br>            <br>            <span class="hljs-comment">// 如果哈希表中存在目标值减去当前值的结果，则返回对应的索引</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(tmp)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(tmp), i&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则，将当前值和索引放入哈希表</span><br>                map.put(nums[i], i);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果没有找到合适的数对，返回空数组（可以根据需求修改）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p><strong>时间复杂度</strong>：O(n)</p><ul><li>因为只需要遍历数组一次，每次查找哈希表的复杂度为 O(1)，总时间复杂度为 O(n)。</li></ul></li><li><p><strong>空间复杂度</strong>：O(n)</p><ul><li>在最坏情况下，哈希表中存储了 n 个元素，因此空间复杂度为 O(n)。</li></ul></li></ul><br><br><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><p><a href="https://leetcode.cn/problems/add-two-numbers/description/">https://leetcode.cn/problems/add-two-numbers/description/</a></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>创建一个虚拟头节点 <code>dummy</code> 以便于处理结果链表。</li><li>使用指针 <code>pre</code> 指向当前处理的节点，初始化为 <code>dummy</code>。</li><li>初始化进位 <code>carry</code> 为 0。</li><li>遍历两个链表，直到都为空：<ul><li>取出当前节点的值 <code>x</code> 和 <code>y</code>，如果链表已经结束则为 0。</li><li>计算当前位的和 <code>sum = x + y + carry</code>。</li><li>更新进位 <code>carry = sum / 10</code>。</li><li>当前位的值为 <code>sum % 10</code>。</li><li>将当前节点的结果添加到结果链表中。</li><li>移动指针到下一个节点。</li></ul></li><li>最后，如果还有进位，添加到结果链表中。</li><li>返回结果链表的下一个节点，即 <code>dummy.next</code>。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (l1 != <span class="hljs-literal">null</span>) ? l1.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (l2 != <span class="hljs-literal">null</span>) ? l2.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y + carry;<br><br>            carry = sum / <span class="hljs-number">10</span>;<br>            sum = sum % <span class="hljs-number">10</span>;<br><br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            pre = pre.next;<br><br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) l2 = l2.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理最高位的进位</span><br>        <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是较长链表的长度。需要遍历一次每个节点。</li><li><strong>空间复杂度</strong>：O(n)，用于存储结果链表。</li></ul><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题可以使用滑动窗口的技巧来解决。我们维护一个窗口，并使用两个指针（left 和 right）来标记窗口的左右边界。同时使用一个哈希集合（Set）来存储当前窗口内的字符。随着右指针的移动，我们检查字符是否重复，如果重复则移动左指针以缩小窗口，直到窗口内没有重复字符为止。在这个过程中，我们记录并更新最长的无重复字符子串的长度。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个哈希集合（Set）用于存储当前窗口内的字符。</li><li>初始化两个指针 left 和 right，均指向字符串的起始位置。</li><li>初始化一个变量 ans 来记录最长无重复字符子串的长度。</li><li>遍历字符串，移动右指针，并检查当前字符是否在哈希集合中。</li><li>如果当前字符不在集合中，则将其加入集合，并继续移动右指针。</li><li>如果当前字符在集合中，则更新最长长度，并移动左指针，直到窗口内不再包含重复字符。</li><li>重复步骤4-6，直到右指针遍历完整个字符串。</li><li>返回 ans 作为结果。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 使用哈希集合来存储当前窗口内的字符</span><br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 滑动窗口的左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录最长无重复字符子串的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>            <span class="hljs-type">Character</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-keyword">if</span>(set.contains(c))&#123;<br>                <span class="hljs-comment">// 更新最长长度</span><br>                ans = Math.max(ans, right - left);<br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-comment">// 移动左指针，直到窗口内不再包含重复字符</span><br>                    <span class="hljs-keyword">if</span>(s.charAt(left) == c)&#123;<br>                        left++;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    set.remove(s.charAt(left));<br>                    left++;<br>                &#125;<br>            &#125;<br>            set.add(c);<br>            right++;<br>        &#125;<br>        <span class="hljs-comment">// 最后一次更新最长长度</span><br>        ans = Math.max(ans, right - left);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是字符串的长度。每个字符在滑动窗口中最多被访问两次（一次通过右指针，一次通过左指针）。</li><li><strong>空间复杂度</strong>：O(min(n, m))，其中 n 是字符串的长度，m 是字符集的大小。在最坏情况下，字符串中的所有字符都不同，因此哈希集合需要存储所有字符。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要特别注意处理边界情况，例如空字符串的输入。</li><li>在计算最长长度时，要确保在循环结束后再进行一次更新，以处理窗口移动到字符串末尾的情况。</li></ul><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h1><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">https://leetcode.cn/problems/median-of-two-sorted-arrays/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。算法的时间复杂度应该为 O(log (m+n))。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题要求时间复杂度为 O(log (m+n))，提示我们可以使用二分查找的方法。我们通过在较短的数组上进行二分查找，找到一个划分，使得左半部分和右半部分的元素个数相等，并且左半部分的最大值小于等于右半部分的最小值。根据这个划分点，我们可以计算出中位数。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>确保 nums1 是较短的数组，以简化后续逻辑。</li><li>初始化两个指针 left 和 right 分别指向 nums1 的左右边界。</li><li>使用二分查找，计算 nums1 和 nums2 的划分点 m1 和 m2。</li><li>检查划分是否符合条件：nums1[m1] &gt;&#x3D; nums2[m2 - 1] 且 nums1[m1 - 1] &lt;&#x3D; nums2[m2]。</li><li>如果条件不满足，根据情况调整 left 或 right 指针，缩小搜索范围。</li><li>计算最终的中位数，根据总长度的奇偶性返回结果。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-comment">// 确保 nums1 是较短的数组</span><br>        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length) &#123;<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 二分查找的中点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-comment">// 计算 nums2 的划分点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - m1;<br><br>            <span class="hljs-comment">// nums1 的划分点过小，增大 left</span><br>            <span class="hljs-keyword">if</span> (m1 &lt; m &amp;&amp; nums1[m1] &lt; nums2[m2 - <span class="hljs-number">1</span>]) &#123;<br>                left = m1 + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// nums1 的划分点过大，减小 right</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m1 &gt; <span class="hljs-number">0</span> &amp;&amp; nums1[m1 - <span class="hljs-number">1</span>] &gt; nums2[m2]) &#123;<br>                right = m1 - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 找到合适的划分点</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> maxleft;<br>                <span class="hljs-comment">// 处理边界情况</span><br>                <span class="hljs-keyword">if</span> (m1 == <span class="hljs-number">0</span>) &#123;<br>                    maxleft = nums2[m2 - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == <span class="hljs-number">0</span>) &#123;<br>                    maxleft = nums1[m1 - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    maxleft = Math.max(nums1[m1 - <span class="hljs-number">1</span>], nums2[m2 - <span class="hljs-number">1</span>]);<br>                &#125;<br><br>                <span class="hljs-comment">// 总长度为奇数，中位数为 maxleft</span><br>                <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> maxleft;<br>                &#125;<br><br>                <span class="hljs-type">int</span> minright;<br>                <span class="hljs-comment">// 处理边界情况</span><br>                <span class="hljs-keyword">if</span> (m1 == m) &#123;<br>                    minright = nums2[m2];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == n) &#123;<br>                    minright = nums1[m1];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    minright = Math.min(nums1[m1], nums2[m2]);<br>                &#125;<br><br>                <span class="hljs-comment">// 总长度为偶数，中位数为 maxleft 和 minright 的平均值</span><br>                <span class="hljs-keyword">return</span> (maxleft + minright) / <span class="hljs-number">2.0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(log(min(m, n)))，其中 m 和 n 分别是两个数组的长度。因为我们在较短的数组上进行二分查找。</li><li><strong>空间复杂度</strong>：O(1)，我们只使用了常数空间来存储变量。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保 nums1 是较短的数组，可以简化边界条件的处理。</li><li>处理边界情况时，确保划分点在数组范围内，避免数组越界。</li><li>总长度为奇数和偶数的情况需要分别处理。</li></ul><h4 id="为什么从较短的数组开始"><a href="#为什么从较短的数组开始" class="headerlink" title="为什么从较短的数组开始"></a>为什么从较短的数组开始</h4><p>减少边界情况：当我们在较短的数组上进行二分查找时，我们只需要考虑较短数组的长度，这样划分点的计算和调整会更加简单。如果我们在较长的数组上进行二分查找，划分点可能会落在较长数组的边界附近，增加处理复杂性。</p><p>避免数组越界：在二分查找过程中，我们需要根据划分点计算两个数组的左半部分和右半部分。如果我们在较短的数组上进行二分查找，更容易确保划分点在数组范围内，避免数组越界。</p><p>优化性能：在较短的数组上进行二分查找，能够更快地收敛到正确的划分点。因为较短数组的长度更小，二分查找的迭代次数也会相应减少，从而提高性能。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>themes</title>
    <link href="/2024/07/26/themes/"/>
    <url>/2024/07/26/themes/</url>
    
    <content type="html"><![CDATA[<h1 id="fluid"><a href="#fluid" class="headerlink" title="fluid"></a>fluid</h1><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p><img src="/2024/07/26/themes/fluid.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>themes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learn_markdown</title>
    <link href="/2024/07/23/learn-markdown/"/>
    <url>/2024/07/23/learn-markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>使用#的数量定义标题的级别，#后面与标题之间有一个空格</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><h6 id="6"><a href="#6" class="headerlink" title="6"></a>6</h6><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>段落与段落之间用空白行分割</p><p>我看见他戴着黑布小帽，穿着黑布大马褂，深青布棉袍，蹒跚地走到铁道边，慢慢探身下去，尚不大难。可是他穿过铁道，要爬上那边月台，就不容易了。他用两手攀着上面，两脚再向上缩；他肥胖的身子向左微倾，显出努力的样子。这时我看见他的背影，我的泪很快地流下来了。我赶紧拭干了泪，怕他看见，也怕别人看见。我再向外看时，他已抱了朱红的橘子望回走了。过铁道时，他先将橘子散放在地上，自己慢慢爬下，再抱起橘子走。到这边时，我赶紧去搀他。他和我走到车上，将橘子一股脑儿放在我的皮大衣上。于是扑扑衣上的泥土，心里很轻松似的，过一会说，“我走了；到那边来信！”我望着他走出去。他走了几步，回过头看见我，说，“进去吧，里边没人。”等他的背影混入来来往往的人里，再找不着了，我便进来坐下，我的眼泪又来了。 — 摘自朱自清的《背影》</p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>静夜思<br>李白<br>床前明月光，疑是地上霜。<br>举头望明月，低头思故乡。</p><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>你__好__   <strong>你好</strong><br><strong>hello</strong> hello<br>你也<strong>好</strong></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p><em>斜体</em><br>_斜体<br>xie<em>斜体</em>ti</p><h3 id="粗体加斜体"><a href="#粗体加斜体" class="headerlink" title="粗体加斜体"></a>粗体加斜体</h3><p><em><strong>粗体斜体</strong></em></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>sssssssss<br>ssssssss<br>ssssss  </p></blockquote><blockquote><p>sdsdsdsd</p></blockquote><p>段落 + 引用</p><blockquote><p>sdsdsdsd</p><p>sdsdsdsd</p></blockquote><p>嵌套块引用</p><blockquote><p>ss</p><blockquote><p>ss</p><blockquote><p>ss</p><blockquote><p>ss</p></blockquote></blockquote></blockquote><p>s</p></blockquote><p>引用 + 其他</p><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h1 id="images"><a href="#images" class="headerlink" title="images"></a>images</h1><p>图片放置格式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[]</span>(png.jpg)<br></code></pre></td></tr></table></figure><p><img src="/2024/07/23/learn-markdown/pdx1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
