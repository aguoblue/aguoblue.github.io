<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hot100-2</title>
    <link href="/2024/07/28/hot100-2/"/>
    <url>/2024/07/28/hot100-2/</url>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">https://leetcode.cn/problems/longest-palindromic-substring/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题要求找到字符串中的最长回文子串。我们可以使用中心扩展法来解决这个问题。对于每个字符，我们尝试将其作为中心，向左右两侧扩展，检查扩展后形成的子串是否为回文。需要注意的是，回文子串的长度可以是奇数也可以是偶数，因此我们需要分别处理这两种情况。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化两个变量 len 和 index 分别记录最长回文子串的长度和起始位置。</li><li>遍历字符串中的每个字符，以当前字符为中心向左右扩展，检查形成的子串是否为回文。</li><li>对于每个字符，分别处理回文子串长度为奇数和偶数的情况。</li><li>在扩展过程中，如果发现更长的回文子串，更新 len 和 index。</li><li>最后，根据 index 和 len 返回最长回文子串。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长回文子串的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长回文子串的起始位置</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 处理奇数长度的回文子串</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>, right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最长回文子串的长度和起始位置</span><br>            <span class="hljs-keyword">if</span> (len &lt; right - left - <span class="hljs-number">1</span>) &#123;<br>                index = left + <span class="hljs-number">1</span>;<br>                len = right - left - <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 处理偶数长度的回文子串</span><br>            left = i;<br>            right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最长回文子串的长度和起始位置</span><br>            <span class="hljs-keyword">if</span> (len &lt; right - left - <span class="hljs-number">1</span>) &#123;<br>                index = left + <span class="hljs-number">1</span>;<br>                len = right - left - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回最长回文子串</span><br>        <span class="hljs-keyword">return</span> s.substring(index, len + index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n^2)，其中 n 是字符串的长度。中心扩展法的每次扩展操作在最坏情况下需要遍历整个字符串，因此总时间复杂度为 O(n^2)。</li><li><strong>空间复杂度</strong>：O(1)，我们只使用了常数空间来存储变量。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要分别处理回文子串长度为奇数和偶数的情况。</li><li>确保在每次扩展后更新最长回文子串的长度和起始位置。</li><li>在进行字符串截取时，注意索引的正确计算，避免越界。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-1</title>
    <link href="/2024/07/26/hot100-1/"/>
    <url>/2024/07/26/hot100-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/description/">https://leetcode.cn/problems/two-sum/description/</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用哈希表存储数组中每个元素的值及其对应的索引。</li><li>在遍历数组的过程中，计算目标值与当前元素的差值。</li><li>检查哈希表中是否存在这个差值。<ul><li>如果存在，则找到了两个数，返回它们的索引。</li><li>如果不存在，将当前元素及其索引存入哈希表。</li></ul></li></ol><p>这种方法只需遍历数组一次，时间复杂度为 O(n)，空间复杂度也为 O(n)。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 创建一个哈希表来存储数值和对应的索引</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> target - nums[i];<br>            <br>            <span class="hljs-comment">// 如果哈希表中存在目标值减去当前值的结果，则返回对应的索引</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(tmp)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(tmp), i&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则，将当前值和索引放入哈希表</span><br>                map.put(nums[i], i);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果没有找到合适的数对，返回空数组（可以根据需求修改）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p><strong>时间复杂度</strong>：O(n)</p><ul><li>因为只需要遍历数组一次，每次查找哈希表的复杂度为 O(1)，总时间复杂度为 O(n)。</li></ul></li><li><p><strong>空间复杂度</strong>：O(n)</p><ul><li>在最坏情况下，哈希表中存储了 n 个元素，因此空间复杂度为 O(n)。</li></ul></li></ul><br><br><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><p><a href="https://leetcode.cn/problems/add-two-numbers/description/">https://leetcode.cn/problems/add-two-numbers/description/</a></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>创建一个虚拟头节点 <code>dummy</code> 以便于处理结果链表。</li><li>使用指针 <code>pre</code> 指向当前处理的节点，初始化为 <code>dummy</code>。</li><li>初始化进位 <code>carry</code> 为 0。</li><li>遍历两个链表，直到都为空：<ul><li>取出当前节点的值 <code>x</code> 和 <code>y</code>，如果链表已经结束则为 0。</li><li>计算当前位的和 <code>sum = x + y + carry</code>。</li><li>更新进位 <code>carry = sum / 10</code>。</li><li>当前位的值为 <code>sum % 10</code>。</li><li>将当前节点的结果添加到结果链表中。</li><li>移动指针到下一个节点。</li></ul></li><li>最后，如果还有进位，添加到结果链表中。</li><li>返回结果链表的下一个节点，即 <code>dummy.next</code>。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (l1 != <span class="hljs-literal">null</span>) ? l1.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (l2 != <span class="hljs-literal">null</span>) ? l2.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y + carry;<br><br>            carry = sum / <span class="hljs-number">10</span>;<br>            sum = sum % <span class="hljs-number">10</span>;<br><br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            pre = pre.next;<br><br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) l2 = l2.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理最高位的进位</span><br>        <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是较长链表的长度。需要遍历一次每个节点。</li><li><strong>空间复杂度</strong>：O(n)，用于存储结果链表。</li></ul><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题可以使用滑动窗口的技巧来解决。我们维护一个窗口，并使用两个指针（left 和 right）来标记窗口的左右边界。同时使用一个哈希集合（Set）来存储当前窗口内的字符。随着右指针的移动，我们检查字符是否重复，如果重复则移动左指针以缩小窗口，直到窗口内没有重复字符为止。在这个过程中，我们记录并更新最长的无重复字符子串的长度。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个哈希集合（Set）用于存储当前窗口内的字符。</li><li>初始化两个指针 left 和 right，均指向字符串的起始位置。</li><li>初始化一个变量 ans 来记录最长无重复字符子串的长度。</li><li>遍历字符串，移动右指针，并检查当前字符是否在哈希集合中。</li><li>如果当前字符不在集合中，则将其加入集合，并继续移动右指针。</li><li>如果当前字符在集合中，则更新最长长度，并移动左指针，直到窗口内不再包含重复字符。</li><li>重复步骤4-6，直到右指针遍历完整个字符串。</li><li>返回 ans 作为结果。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 使用哈希集合来存储当前窗口内的字符</span><br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 滑动窗口的左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录最长无重复字符子串的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>            <span class="hljs-type">Character</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-keyword">if</span>(set.contains(c))&#123;<br>                <span class="hljs-comment">// 更新最长长度</span><br>                ans = Math.max(ans, right - left);<br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-comment">// 移动左指针，直到窗口内不再包含重复字符</span><br>                    <span class="hljs-keyword">if</span>(s.charAt(left) == c)&#123;<br>                        left++;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    set.remove(s.charAt(left));<br>                    left++;<br>                &#125;<br>            &#125;<br>            set.add(c);<br>            right++;<br>        &#125;<br>        <span class="hljs-comment">// 最后一次更新最长长度</span><br>        ans = Math.max(ans, right - left);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是字符串的长度。每个字符在滑动窗口中最多被访问两次（一次通过右指针，一次通过左指针）。</li><li><strong>空间复杂度</strong>：O(min(n, m))，其中 n 是字符串的长度，m 是字符集的大小。在最坏情况下，字符串中的所有字符都不同，因此哈希集合需要存储所有字符。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要特别注意处理边界情况，例如空字符串的输入。</li><li>在计算最长长度时，要确保在循环结束后再进行一次更新，以处理窗口移动到字符串末尾的情况。</li></ul><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h1><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">https://leetcode.cn/problems/median-of-two-sorted-arrays/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。算法的时间复杂度应该为 O(log (m+n))。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题要求时间复杂度为 O(log (m+n))，提示我们可以使用二分查找的方法。我们通过在较短的数组上进行二分查找，找到一个划分，使得左半部分和右半部分的元素个数相等，并且左半部分的最大值小于等于右半部分的最小值。根据这个划分点，我们可以计算出中位数。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>确保 nums1 是较短的数组，以简化后续逻辑。</li><li>初始化两个指针 left 和 right 分别指向 nums1 的左右边界。</li><li>使用二分查找，计算 nums1 和 nums2 的划分点 m1 和 m2。</li><li>检查划分是否符合条件：nums1[m1] &gt;&#x3D; nums2[m2 - 1] 且 nums1[m1 - 1] &lt;&#x3D; nums2[m2]。</li><li>如果条件不满足，根据情况调整 left 或 right 指针，缩小搜索范围。</li><li>计算最终的中位数，根据总长度的奇偶性返回结果。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-comment">// 确保 nums1 是较短的数组</span><br>        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length) &#123;<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 二分查找的中点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-comment">// 计算 nums2 的划分点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - m1;<br><br>            <span class="hljs-comment">// nums1 的划分点过小，增大 left</span><br>            <span class="hljs-keyword">if</span> (m1 &lt; m &amp;&amp; nums1[m1] &lt; nums2[m2 - <span class="hljs-number">1</span>]) &#123;<br>                left = m1 + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// nums1 的划分点过大，减小 right</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m1 &gt; <span class="hljs-number">0</span> &amp;&amp; nums1[m1 - <span class="hljs-number">1</span>] &gt; nums2[m2]) &#123;<br>                right = m1 - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 找到合适的划分点</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> maxleft;<br>                <span class="hljs-comment">// 处理边界情况</span><br>                <span class="hljs-keyword">if</span> (m1 == <span class="hljs-number">0</span>) &#123;<br>                    maxleft = nums2[m2 - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == <span class="hljs-number">0</span>) &#123;<br>                    maxleft = nums1[m1 - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    maxleft = Math.max(nums1[m1 - <span class="hljs-number">1</span>], nums2[m2 - <span class="hljs-number">1</span>]);<br>                &#125;<br><br>                <span class="hljs-comment">// 总长度为奇数，中位数为 maxleft</span><br>                <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> maxleft;<br>                &#125;<br><br>                <span class="hljs-type">int</span> minright;<br>                <span class="hljs-comment">// 处理边界情况</span><br>                <span class="hljs-keyword">if</span> (m1 == m) &#123;<br>                    minright = nums2[m2];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == n) &#123;<br>                    minright = nums1[m1];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    minright = Math.min(nums1[m1], nums2[m2]);<br>                &#125;<br><br>                <span class="hljs-comment">// 总长度为偶数，中位数为 maxleft 和 minright 的平均值</span><br>                <span class="hljs-keyword">return</span> (maxleft + minright) / <span class="hljs-number">2.0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(log(min(m, n)))，其中 m 和 n 分别是两个数组的长度。因为我们在较短的数组上进行二分查找。</li><li><strong>空间复杂度</strong>：O(1)，我们只使用了常数空间来存储变量。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保 nums1 是较短的数组，可以简化边界条件的处理。</li><li>处理边界情况时，确保划分点在数组范围内，避免数组越界。</li><li>总长度为奇数和偶数的情况需要分别处理。</li></ul><h4 id="为什么从较短的数组开始"><a href="#为什么从较短的数组开始" class="headerlink" title="为什么从较短的数组开始"></a>为什么从较短的数组开始</h4><p>减少边界情况：当我们在较短的数组上进行二分查找时，我们只需要考虑较短数组的长度，这样划分点的计算和调整会更加简单。如果我们在较长的数组上进行二分查找，划分点可能会落在较长数组的边界附近，增加处理复杂性。</p><p>避免数组越界：在二分查找过程中，我们需要根据划分点计算两个数组的左半部分和右半部分。如果我们在较短的数组上进行二分查找，更容易确保划分点在数组范围内，避免数组越界。</p><p>优化性能：在较短的数组上进行二分查找，能够更快地收敛到正确的划分点。因为较短数组的长度更小，二分查找的迭代次数也会相应减少，从而提高性能。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>themes</title>
    <link href="/2024/07/26/themes/"/>
    <url>/2024/07/26/themes/</url>
    
    <content type="html"><![CDATA[<h1 id="fluid"><a href="#fluid" class="headerlink" title="fluid"></a>fluid</h1><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p><img src="/2024/07/26/themes/fluid.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>themes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learn_markdown</title>
    <link href="/2024/07/23/learn-markdown/"/>
    <url>/2024/07/23/learn-markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>使用#的数量定义标题的级别，#后面与标题之间有一个空格</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><h6 id="6"><a href="#6" class="headerlink" title="6"></a>6</h6><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>段落与段落之间用空白行分割</p><p>我看见他戴着黑布小帽，穿着黑布大马褂，深青布棉袍，蹒跚地走到铁道边，慢慢探身下去，尚不大难。可是他穿过铁道，要爬上那边月台，就不容易了。他用两手攀着上面，两脚再向上缩；他肥胖的身子向左微倾，显出努力的样子。这时我看见他的背影，我的泪很快地流下来了。我赶紧拭干了泪，怕他看见，也怕别人看见。我再向外看时，他已抱了朱红的橘子望回走了。过铁道时，他先将橘子散放在地上，自己慢慢爬下，再抱起橘子走。到这边时，我赶紧去搀他。他和我走到车上，将橘子一股脑儿放在我的皮大衣上。于是扑扑衣上的泥土，心里很轻松似的，过一会说，“我走了；到那边来信！”我望着他走出去。他走了几步，回过头看见我，说，“进去吧，里边没人。”等他的背影混入来来往往的人里，再找不着了，我便进来坐下，我的眼泪又来了。 — 摘自朱自清的《背影》</p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>静夜思<br>李白<br>床前明月光，疑是地上霜。<br>举头望明月，低头思故乡。</p><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p>你__好__   <strong>你好</strong><br><strong>hello</strong> hello<br>你也<strong>好</strong></p><h1 id="images"><a href="#images" class="headerlink" title="images"></a>images</h1><p>图片放置格式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[]</span>(png.jpg)<br></code></pre></td></tr></table></figure><p><img src="/2024/07/23/learn-markdown/pdx1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
