<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker部署redis</title>
    <link href="/2024/08/20/docker%E9%83%A8%E7%BD%B2redis/"/>
    <url>/2024/08/20/docker%E9%83%A8%E7%BD%B2redis/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>docker环境已经搭建好</li><li>了解docker基本的命令行知识。</li><li>了解redis的基本配置。<ul><li>配置文件redis.conf</li></ul></li></ul><h2 id="拉取-Redis-镜像"><a href="#拉取-Redis-镜像" class="headerlink" title="拉取 Redis 镜像"></a>拉取 Redis 镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull redis<br></code></pre></td></tr></table></figure><h2 id="Redis-配置文件"><a href="#Redis-配置文件" class="headerlink" title="Redis 配置文件"></a>Redis 配置文件</h2><p>下载配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://download.redis.io/redis-stable/redis.conf<br></code></pre></td></tr></table></figure><p>修改配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> 127.0.0.1 <span class="hljs-comment"># 这行要注释掉，解除本地连接限制</span><br>protected-mode no <span class="hljs-comment"># 默认yes，如果设置为yes，则只允许在本机的回环连接，其他机器无法连接。</span><br>daemonize no <span class="hljs-comment"># 默认no 为不守护进程模式，docker部署不需要改为yes，docker run -d本身就是后台启动，不然会冲突</span><br>requirepass 123456 <span class="hljs-comment"># 设置密码</span><br>appendonly <span class="hljs-built_in">yes</span> <span class="hljs-comment"># 持久化</span><br></code></pre></td></tr></table></figure><h2 id="创建并运行-Redis-容器"><a href="#创建并运行-Redis-容器" class="headerlink" title="创建并运行 Redis 容器"></a>创建并运行 Redis 容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name my-redis \<br>-v /mydata/redis/redis.conf:/usr/local/etc/redis/redis.conf \<br>-v /mydata/redis/data:/data \<br>-p 6379:6379 \<br>-d redis redis-server /usr/local/etc/redis/redis.conf<br></code></pre></td></tr></table></figure><ul><li>–name my-redis：为容器指定名称为 my-redis。</li><li>-v &#x2F;mydata&#x2F;redis&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf：将本地的 redis.conf 文件映射到容器内的 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf，Redis 将使用此配置文件启动。</li><li>-v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data：将本地的 &#x2F;mydata&#x2F;redis&#x2F;data 目录映射到容器内的 &#x2F;data 目录，Redis 的数据将存储在这个目录中。</li><li>-p 6379:6379：将容器内的 6379 端口映射到主机的 6379 端口，使你能够通过 localhost:6379 访问 Redis 服务。</li><li>-d redis redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf：后台运行 Redis，并使用自定义的配置文件。</li></ul><h2 id="redis-客户端"><a href="#redis-客户端" class="headerlink" title="redis 客户端"></a>redis 客户端</h2><ul><li>redis-cli：redis 命令行客户端，可以用来连接到 Redis 服务器并执行命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it my-redis redis-cli <br>127.0.0.1:6379&gt; AUTH yourpassword<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure></li><li>another redis desktop manager</li></ul><h2 id="停止容器："><a href="#停止容器：" class="headerlink" title="停止容器："></a>停止容器：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop my-redis<br></code></pre></td></tr></table></figure><h2 id="启动已经停止的容器："><a href="#启动已经停止的容器：" class="headerlink" title="启动已经停止的容器："></a>启动已经停止的容器：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start my-redis<br></code></pre></td></tr></table></figure><h2 id="删除容器（在确保数据备份的情况下）："><a href="#删除容器（在确保数据备份的情况下）：" class="headerlink" title="删除容器（在确保数据备份的情况下）："></a>删除容器（在确保数据备份的情况下）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> my-redis<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git参考</title>
    <link href="/2024/08/19/git%E5%8F%82%E8%80%83/"/>
    <url>/2024/08/19/git%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --recurse-submodules url<br></code></pre></td></tr></table></figure><h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br><br>git <span class="hljs-built_in">log</span> --oneline --graph --decorate --all<br></code></pre></td></tr></table></figure><p>使用 git rebase -i 定位更远的历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase -i HEAD~6<br></code></pre></td></tr></table></figure><p>git reflog 是一种查看所有对 HEAD 的移动历史的命令，包括那些在 detached HEAD 状态下所做的提交。这是查看以前的 detached HEAD 提交的一个非常有用的工具。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">git <span class="hljs-built_in">ref</span>log<br></code></pre></td></tr></table></figure><p>git reflog 记录了每一次 HEAD 的更新，包括切换分支、回滚、合并、detached HEAD 状态下的提交等。即使某个提交不再在任何分支的历史中，reflog 仍然会显示它。</p><hr><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -a<br></code></pre></td></tr></table></figure><p>新建分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b new-branch-name<br></code></pre></td></tr></table></figure><hr><h2 id="创建、修改、回退分支"><a href="#创建、修改、回退分支" class="headerlink" title="创建、修改、回退分支"></a>创建、修改、回退分支</h2><p>从某次修改创建新分支<br>如果你想从某个特定的提交（而不是当前的提交）创建一个新分支，你可以使用提交哈希值来指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b new-branch-name commit-hash<br></code></pre></td></tr></table></figure><ul><li>commit-hash 是你要基于的那次提交的哈希值（你可以通过 git log 查看这些哈希值）。</li><li>new-branch-name 是你想创建的新分支的名称。</li></ul><p>完全回退 更改HEAD指向的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard commit-hash<br></code></pre></td></tr></table></figure><p>将 master 分支重置到当前的 HEAD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -f master HEAD<br></code></pre></td></tr></table></figure><p>将 master 分支指向 507aec03 提交<br>如果你想让 master 分支直接指向这个提交，使其成为 master 的最新提交，可以使用以下命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">git</span> reset --hard <span class="hljs-number">507</span>aec03<br></code></pre></td></tr></table></figure><ul><li>git checkout master：切换回 master 分支。  </li><li>git reset –hard 507aec03：强制将 master 分支指向 507aec03，并使工作目录匹配该提交的状态。<br>这将使 master 分支直接指向提交 507aec03，并且会丢弃 master 分支上比 507aec03 更新的提交（如果有的话）。</li></ul><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker部署nginx</title>
    <link href="/2024/08/16/docker%E9%83%A8%E7%BD%B2nginx/"/>
    <url>/2024/08/16/docker%E9%83%A8%E7%BD%B2nginx/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>docker环境已经搭建好</li><li>了解docker基本的命令行知识。</li><li>了解nginx的基本配置。<ul><li>配置文件nginx.conf</li><li>资源目录</li></ul></li></ul><h2 id="拉取-Nginx-镜像"><a href="#拉取-Nginx-镜像" class="headerlink" title="拉取 Nginx 镜像"></a>拉取 Nginx 镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull nginx:latest<br></code></pre></td></tr></table></figure><h2 id="创建并运行-Nginx-容器"><a href="#创建并运行-Nginx-容器" class="headerlink" title="创建并运行 Nginx 容器"></a>创建并运行 Nginx 容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name nginx-container -p 80:80 \<br>  -v /your_dir/www:/usr/share/nginx/html \<br>  -v /your_dir/nginx/conf.d:/etc/nginx/conf.d \<br>  -d nginx:latest<br></code></pre></td></tr></table></figure><ul><li><p>-p 80:80：将容器内的 80 端口映射到主机的 80 端口，这样外部就可以通过主机的 80 端口访问到 Nginx 服务器。</p></li><li><p>-v &#x2F;your_dir&#x2F;www:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html：将本地目录 &#x2F;your_dir&#x2F;www 挂载到容器内的 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html，这是 Nginx 默认的网页根目录。</p></li><li><p>-v &#x2F;your_dir&#x2F;nginx&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d：将本地目录 &#x2F;your_dir&#x2F;nginx&#x2F;conf.d 挂载到容器内的 &#x2F;etc&#x2F;nginx&#x2F;conf.d，这个目录用于存放 Nginx 的自定义配置文件。</p></li></ul><p>这个容器挂载了外部的目录，如果配置文件的目录为空，那么容器里对应的目录也会为空。所以访问80端口时会出现 <code>This site can’t be reached</code></p><h2 id="查看官方容器里初始的文件"><a href="#查看官方容器里初始的文件" class="headerlink" title="查看官方容器里初始的文件"></a>查看官方容器里初始的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> -it --name nginx-container1 -p 8080:80 nginx bash<br><span class="hljs-built_in">cat</span> /etc/nginx/conf.d/default.conf<br><span class="hljs-built_in">cat</span> /usr/share/nginx/html/index.html<br><span class="hljs-built_in">cat</span> /usr/share/nginx/html/50.html<br></code></pre></td></tr></table></figure><h3 id="default-conf"><a href="#default-conf" class="headerlink" title="default.conf"></a>default.conf</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs conf">server &#123;<br>    listen       80;<br>    server_name  localhost;<br><br>    #access_log  /var/log/nginx/host.access.log  main;<br><br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>    #error_page  404              /404.html;<br><br>    # redirect server error pages to the static page /50x.html<br>    #<br>    error_page   500 502 503 504  /50x.html;<br>    location = /50x.html &#123;<br>        root   /usr/share/nginx/html;<br>    &#125;<br><br>    # proxy the PHP scripts to Apache listening on 127.0.0.1:80<br>    #<br>    #location ~ \.php$ &#123;<br>    #    proxy_pass   http://127.0.0.1;<br>    #&#125;<br><br>    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000<br>    #<br>    #location ~ \.php$ &#123;<br>    #    root           html;<br>    #    fastcgi_pass   127.0.0.1:9000;<br>    #    fastcgi_index  index.php;<br>    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;<br>    #    include        fastcgi_params;<br>    #&#125;<br><br>    # deny access to .htaccess files, if Apache&#x27;s document root<br>    # concurs with nginx&#x27;s one<br>    #<br>    #location ~ /\.ht &#123;<br>    #    deny  all;<br>    #&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="50-html"><a href="#50-html" class="headerlink" title="50.html"></a>50.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Error<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">html</span> &#123; <span class="hljs-attribute">color-scheme</span>: light dark; &#125;</span><br><span class="language-css"><span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">35em</span>; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css"><span class="hljs-attribute">font-family</span>: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>An error occurred.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Sorry, the page you are looking for is currently unavailable.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>Please try again later.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>If you are the system administrator of this resource then you should check<br>the error log for details.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>Faithfully yours, nginx.<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Welcome to nginx!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">html</span> &#123; <span class="hljs-attribute">color-scheme</span>: light dark; &#125;</span><br><span class="language-css"><span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">35em</span>; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css"><span class="hljs-attribute">font-family</span>: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to nginx!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>For online documentation and support please refer to<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://nginx.org/&quot;</span>&gt;</span>nginx.org<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>Commercial support is available at<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://nginx.com/&quot;</span>&gt;</span>nginx.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>Thank you for using nginx.<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h2><p>在挂载目录 <code>/your_dir/nginx/conf.d</code>下创建 <code>default.conf</code> 文件，内容如上面容器里的文件输出所示。</p><p>更改配置后需要重启服务<strong>或者</strong>直接重启容器，选择一种</p><h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it nginx-container bash<br>nginx -s reload<br></code></pre></td></tr></table></figure><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart nginx-container<br></code></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>容器启动后，你可以通过浏览器访问 <a href="http://localhost/">http://localhost</a> 来查看你的 Nginx 服务器。如果你挂载了自定义的静态文件目录，你应该能够看到这些文件被正确地提供。</p><h2 id="管理-Nginx-容器"><a href="#管理-Nginx-容器" class="headerlink" title="管理 Nginx 容器"></a>管理 Nginx 容器</h2><p>停止容器：如果你需要停止运行中的 Nginx 容器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop nginx-container<br></code></pre></td></tr></table></figure><p>启动容器：要重新启动容器，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start nginx-container<br></code></pre></td></tr></table></figure><p>删除容器：如果你不再需要这个容器，可以将其删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> nginx-container<br></code></pre></td></tr></table></figure><p>日志查看和调试<br>你可以使用以下命令查看 Nginx 容器的日志，帮助你进行调试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs nginx-container<br></code></pre></td></tr></table></figure><p>如果你希望实时查看日志，可以使用 -f 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f nginx-container<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pythondjango.cn/python/tools/5-nginx-configuration/">https://pythondjango.cn/python/tools/5-nginx-configuration/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker部署mysql</title>
    <link href="/2024/08/16/docker%E9%83%A8%E7%BD%B2mysql/"/>
    <url>/2024/08/16/docker%E9%83%A8%E7%BD%B2mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>docker环境已经搭建好</li><li>了解docker基本的命令行知识。</li><li>了解mysql的基本概念和操作。</li></ul><h2 id="拉取mysql镜像"><a href="#拉取mysql镜像" class="headerlink" title="拉取mysql镜像"></a>拉取mysql镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull mysql:5.7<br></code></pre></td></tr></table></figure><h2 id="创建并运行-MySQL-容器"><a href="#创建并运行-MySQL-容器" class="headerlink" title="创建并运行 MySQL 容器"></a>创建并运行 MySQL 容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run  \<br>  --name mysql-container \<br>  -e MYSQL_ROOT_PASSWORD=my-secret-pw \<br>  -p 3306:3306 \<br>  -v /your_dir/data/mysql/log:/var/log/mysql \<br>  -v /your_dir/data/mysql/data:/var/lib/mysql \<br>  -v /your_dir/data/mysql/conf:/etc/mysql/conf.d \<br>  -d \ <br>  mysql:5.7<br></code></pre></td></tr></table></figure><ul><li>docker run：这个命令用于创建并运行一个新的容器。</li><li>–name mysql-container：为容器指定一个名称，这里将容器命名为 mysql-container。以后你可以通过这个名称来引用或管理这个容器。</li><li>-e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw：通过设置环境变量 MYSQL_ROOT_PASSWORD 来指定 MySQL 数据库的 root 用户密码。这里设置密码为 my-secret-pw。</li><li>-p 3306:3306：映射端口。将主机的 3306 端口映射到容器内的 3306 端口。3306 是 MySQL 的默认端口号，这样主机上的应用程序可以通过访问 localhost:3306 来与容器中的 MySQL 进行通信。</li><li>-v &#x2F;your_dir&#x2F;data&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql：挂载卷。将主机上的 &#x2F;your_dir&#x2F;data&#x2F;mysql&#x2F;log 目录挂载到容器内的 &#x2F;var&#x2F;log&#x2F;mysql 目录。这样可以将 MySQL 的日志文件保存在主机上，便于查看和管理。</li><li>-v &#x2F;your_dir&#x2F;data&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql：将主机上的 &#x2F;your_dir&#x2F;data&#x2F;mysql&#x2F;data 目录挂载到容器内的 &#x2F;var&#x2F;lib&#x2F;mysql 目录。这是 MySQL 默认的数据存储位置，挂载卷的作用是将 MySQL 的数据文件存储在主机上，即使容器被删除或重新创建，数据也不会丢失。</li><li>-v &#x2F;your_dir&#x2F;data&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d：将主机上的 &#x2F;your_dir&#x2F;data&#x2F;mysql&#x2F;conf 目录挂载到容器内的 &#x2F;etc&#x2F;mysql&#x2F;conf.d 目录。这个目录通常用于存放 MySQL 的配置文件。通过挂载主机上的目录，你可以自定义 MySQL 的配置，并且容器会自动加载这些配置。</li><li>-d：让容器在后台运行（守护模式）。使用这个选项后，容器将会在后台运行，而不会占据你的终端。</li><li>mysql:5.7：指定使用 MySQL 5.7 版本的 Docker 镜像。如果你的应用程序需要使用 MySQL 5.7，这里就指定这个版本。</li></ul><h2 id="管理-MySQL-容器"><a href="#管理-MySQL-容器" class="headerlink" title="管理 MySQL 容器"></a>管理 MySQL 容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a <span class="hljs-comment"># 查看所有容器</span><br>docker start mysql-container <span class="hljs-comment"># 启动容器</span><br>docker stop mysql-container <span class="hljs-comment"># 停止容器</span><br>docker restart mysql-container <span class="hljs-comment"># 重启容器</span><br>docker <span class="hljs-built_in">rm</span> mysql-container <span class="hljs-comment"># 删除容器</span><br>docker logs mysql-container <span class="hljs-comment"># 查看容器日志</span><br></code></pre></td></tr></table></figure><h2 id="连接-MySQL-数据库"><a href="#连接-MySQL-数据库" class="headerlink" title="连接 MySQL 数据库"></a>连接 MySQL 数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mysql-container mysql -uroot -p<br></code></pre></td></tr></table></figure><ul><li>docker exec：这个命令用于在已经运行的容器中执行命令。你可以使用它来在容器内部运行新的进程。</li><li>-it：这是两个参数的组合，分别为 -i 和 -t，它们的作用是：</li><li>-i (–interactive)：保持标准输入流打开，这样你可以在容器内输入命令。</li><li>-t (–tty)：分配一个伪终端，提供一个终端界面，让你能够以交互方式工作。</li><li>mysql-container：这是容器的名称。在这条命令中，你是在名为 mysql-container 的容器内执行后续的命令。</li><li>mysql：这是要在容器内执行的命令。在这个例子中，我们是在容器内启动 MySQL 客户端。MySQL 客户端是一个命令行工具，允许你连接到 MySQL 服务器并执行 SQL 查询。</li><li>-uroot：指定要以 MySQL 的 root 用户身份登录。-u 选项用于指定用户名，root 是默认的超级用户。</li><li>-p：提示输入密码。使用这个选项后，命令行会提示你输入 root 用户的密码。你在之前创建容器时设置的密码（例如 my-secret-pw）就是你在此处需要输入的。</li></ul><h2 id="可以使用可视化工具来连接和管理-MySQL"><a href="#可以使用可视化工具来连接和管理-MySQL" class="headerlink" title="可以使用可视化工具来连接和管理 MySQL"></a>可以使用可视化工具来连接和管理 MySQL</h2><ul><li>mysql-workbench<br>官网<br><a href="https://www.mysql.com/products/workbench/">https://www.mysql.com/products/workbench/</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://hub.docker.com/_/mysql">https://hub.docker.com/_/mysql</a></li><li>配置文件：<a href="https://developer.aliyun.com/article/822935">https://developer.aliyun.com/article/822935</a></li><li>GPT</li></ul>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-14</title>
    <link href="/2024/08/14/hot100-14/"/>
    <url>/2024/08/14/hot100-14/</url>
    
    <content type="html"><![CDATA[<h1 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h1><p><a href="https://leetcode.cn/problems/sort-list/description/">https://leetcode.cn/problems/sort-list/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表的头结点 <code>head</code>，请将其按升序排列并返回排序后的链表。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>排序链表可以使用归并排序的思想。归并排序在链表中的时间复杂度是 O(n log n)，而且由于链表的特性，归并排序在链表中比较容易实现。</p><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol><li><p><strong>拆分链表</strong>：</p><ul><li>使用快慢指针（<code>fast</code> 和 <code>slow</code>）找到链表的中间节点。<code>slow</code> 指针每次移动一步，<code>fast</code> 指针每次移动两步。当 <code>fast</code> 到达链表末尾时，<code>slow</code> 就指向了链表的中间节点。</li><li>将链表从中间分成两部分，分别对两部分递归调用排序函数。</li></ul></li><li><p><strong>合并排序后的链表</strong>：</p><ul><li>对两个排序后的子链表进行合并，合并时按照升序的顺序进行。</li><li>使用一个哨兵节点（<code>dummy</code>）作为合并后的新链表的头结点，逐步连接两个子链表中的节点。</li></ul></li><li><p><strong>递归结束条件</strong>：</p><ul><li>如果链表为空或只有一个节点时，直接返回该节点（已经是有序的）。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 使用快慢指针找到链表的中间节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head.next;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 分割链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> slow.next;<br>        slow.next = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 对左右两部分递归排序</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> sortList(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sortList(node);<br><br>        <span class="hljs-comment">// 合并两个排序后的链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (left.val &lt; right.val) &#123;<br>                tmp.next = left;<br>                left = left.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp.next = right;<br>                right = right.next;<br>            &#125;<br>            tmp = tmp.next;<br>        &#125;<br>        tmp.next = (left == <span class="hljs-literal">null</span>) ? right : left;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n log n)，其中 <code>n</code> 是链表的节点数。归并排序的时间复杂度为 O(n log n)。</li><li><strong>空间复杂度</strong>: O(log n)，由于递归调用栈的深度为 log n。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>快慢指针</strong>：使用快慢指针来找到链表的中间节点，并将链表分为两部分。<code>slow</code> 指针用于标记链表中间节点的位置，<code>fast</code> 指针用于确定结束位置。</li><li><strong>递归终止条件</strong>：当链表为空或只有一个节点时，递归终止，因为这时候链表已经是有序的。</li><li><strong>合并过程</strong>：通过哨兵节点 <code>dummy</code> 简化链表的合并操作，最终返回哨兵节点的下一个节点 <code>dummy.next</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-13</title>
    <link href="/2024/08/13/hot100-13/"/>
    <url>/2024/08/13/hot100-13/</url>
    
    <content type="html"><![CDATA[<h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h1><p><a href="https://leetcode.cn/problems/word-break/description/">https://leetcode.cn/problems/word-break/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code>，则返回 <code>true</code>。注意，不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。定义一个布尔数组 <code>dp</code>，其中 <code>dp[i]</code> 表示字符串 <code>s</code> 的前 <code>i</code> 个字符是否可以由字典中的单词拼接而成。</p><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol><li>初始化一个布尔数组 <code>dp</code>，长度为 <code>s.length() + 1</code>，其中 <code>dp[0] = true</code> 表示空字符串是可以被字典中的单词拼接而成的。</li><li>遍历字符串 <code>s</code> 的每个位置 <code>i</code>，对于每个 <code>i</code>，再遍历其之前的每个位置 <code>j</code>：<ul><li>如果 <code>dp[j]</code> 为 <code>true</code>，并且 <code>s.substring(j, i)</code> 存在于字典 <code>wordDict</code> 中，那么 <code>dp[i] = true</code>，表示前 <code>i</code> 个字符可以由字典中的单词拼接而成。</li></ul></li><li>最终返回 <code>dp[s.length()]</code>，表示整个字符串 <code>s</code> 是否可以被字典中的单词拼接而成。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict); <span class="hljs-comment">// 将字典中的单词放入哈希集合中，便于查找</span><br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 动态规划数组，长度为 s.length() + 1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 空字符串可以被拼接</span><br><br>        <span class="hljs-comment">// 遍历字符串的每个位置 i</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-comment">// 遍历 i 之前的每个位置 j</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-comment">// 如果 dp[j] 为 true 并且 s.substring(j, i) 存在于字典中</span><br>                <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;<br>                    dp[i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 则 dp[i] 为 true</span><br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 一旦找到有效的分割方式，就可以停止内层循环</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[s.length()]; <span class="hljs-comment">// 返回整个字符串是否可以被拼接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n^2)，其中 <code>n</code> 是字符串 <code>s</code> 的长度。外层循环遍历字符串的每个位置，内层循环检查每个可能的分割点。</li><li><strong>空间复杂度</strong>: O(n)，其中 <code>n</code> 是字符串 <code>s</code> 的长度。我们使用了一个长度为 <code>n + 1</code> 的布尔数组来存储中间结果。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>通过将 <code>wordDict</code> 中的单词存入哈希集合 <code>set</code>，可以提高查找单词的效率。</li><li>动态规划数组 <code>dp</code> 用于记录字符串的前缀是否可以被字典中的单词拼接而成，从而避免重复计算。</li><li>在实现动态规划时，内层循环中的 <code>break</code> 可以在找到一个有效的分割点后立即退出，进一步提高算法的效率。</li></ul><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">https://leetcode.cn/problems/linked-list-cycle/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表的头节点 <code>head</code>，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。如果链表中存在环，则返回 <code>true</code>，否则返回 <code>false</code>。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>判断链表中是否存在环可以通过使用两个指针来实现，这种方法也被称为 <strong>快慢指针法</strong> 或 <strong>龟兔赛跑算法</strong>。</p><h4 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol><li>初始化两个指针 <code>slow</code> 和 <code>fast</code>，都指向链表的头节点 <code>head</code>。</li><li><code>slow</code> 指针每次向前移动一步，而 <code>fast</code> 指针每次向前移动两步。</li><li>如果链表中存在环，<code>fast</code> 指针最终会追上 <code>slow</code> 指针（即它们会在环中相遇）。如果 <code>slow</code> 和 <code>fast</code> 指针相遇，则返回 <code>true</code>。</li><li>如果 <code>fast</code> 指针到达链表的末尾（<code>fast == null</code> 或 <code>fast.next == null</code>），则链表中不存在环，返回 <code>false</code>。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;           <span class="hljs-comment">// 慢指针每次移动一步</span><br>            fast = fast.next.next;      <span class="hljs-comment">// 快指针每次移动两步</span><br>            <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 如果慢指针和快指针相遇，说明存在环</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果快指针到达链表末尾，说明不存在环</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是链表的节点数。最坏情况下，<code>fast</code> 指针会遍历链表中的每个节点一次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了两个指针 <code>slow</code> 和 <code>fast</code>，没有使用额外的存储空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>快慢指针法的核心思想是利用两个速度不同的指针。如果链表中存在环，两个指针最终一定会在环内相遇。</li><li>需要注意，初始情况下，<code>slow</code> 和 <code>fast</code> 都指向 <code>head</code>，这样可以正确处理链表为空或只有一个节点的情况。</li><li>在代码实现时，需要特别注意判断 <code>fast</code> 指针和 <code>fast.next</code> 是否为 <code>null</code>，以避免出现空指针异常。</li></ul><h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">https://leetcode.cn/problems/linked-list-cycle-ii/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表的头节点 <code>head</code>，返回链表开始入环的第一个节点。如果链表无环，则返回 <code>null</code>。</p><p>链表中如果有某个节点可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p>注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改链表。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题可以通过使用 <strong>快慢指针法</strong> 解决，具体步骤如下：</p><ol><li><p><strong>检测是否存在环</strong>：</p><ul><li>初始化两个指针 <code>slow</code> 和 <code>fast</code>，都指向链表的头节点 <code>head</code>。</li><li><code>slow</code> 指针每次移动一步，而 <code>fast</code> 指针每次移动两步。</li><li>如果链表中存在环，那么 <code>slow</code> 和 <code>fast</code> 最终会在环中相遇。</li><li>如果 <code>fast</code> 到达链表的末尾（<code>fast == null</code> 或 <code>fast.next == null</code>），则链表中没有环，返回 <code>null</code>。</li></ul></li><li><p><strong>寻找入环的第一个节点</strong>：</p><ul><li>当 <code>slow</code> 和 <code>fast</code> 在环中相遇后，将 <code>slow</code> 指针重新指向链表的头节点 <code>head</code>，<code>fast</code> 指针保持在相遇点。</li><li>接下来，<code>slow</code> 和 <code>fast</code> 指针每次都只移动一步，最终它们会在环的起点处相遇，这个相遇点即为链表入环的第一个节点。</li></ul></li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <br>        <span class="hljs-comment">// 检测是否存在环</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果没有环，返回 null</span><br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-comment">// 找到入环的第一个节点</span><br>        slow = head;<br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> slow; <span class="hljs-comment">// 或 fast，它们相遇的节点即为入环的第一个节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是链表的节点数。最坏情况下，我们需要遍历链表中的所有节点。</li><li><strong>空间复杂度</strong>: O(1)，我们只使用了两个指针 <code>slow</code> 和 <code>fast</code>，没有使用额外的存储空间。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>通过快慢指针法，可以高效地检测链表中是否存在环，并找到入环的第一个节点。</li><li>在代码实现时，必须先判断是否存在环，如果不存在环直接返回 <code>null</code>，否则继续查找入环的节点。</li><li>快慢指针相遇后，将 <code>slow</code> 指针重新指向头节点，并与 <code>fast</code> 指针一起移动，直到它们再次相遇，这个相遇点就是入环的第一个节点。</li></ul><h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a>146. LRU 缓存</h1><p><a href="https://leetcode.cn/problems/lru-cache/description/">https://leetcode.cn/problems/lru-cache/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。实现 LRUCache 类：</p><ul><li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存。</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code>。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code>；如果不存在，则向缓存中插入该组 <code>key-value</code>。如果插入操作导致关键字数量超过 <code>capacity</code>，则应该逐出最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 O(1) 的平均时间复杂度运行。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>LRU 缓存要求我们以 O(1) 的时间复杂度实现数据的存取和更新。要实现这个要求，可以结合使用 <strong>哈希表</strong> 和 <strong>双向链表</strong>。</p><ul><li><strong>哈希表</strong> 用于在 O(1) 时间复杂度内查找元素。</li><li><strong>双向链表</strong> 用于记录元素的访问顺序，以便在容量超出时，可以快速删除最久未使用的元素。</li></ul><h4 id="具体步骤-2"><a href="#具体步骤-2" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol><li><p><strong>数据结构</strong>：</p><ul><li>一个哈希表 <code>map</code>，用于存储 <code>key</code> 到 <code>双向链表节点</code> 的映射。</li><li>一个双向链表，链表头部存储最近使用的元素，链表尾部存储最久未使用的元素。</li></ul></li><li><p><strong><code>get</code> 操作</strong>：</p><ul><li>如果 <code>key</code> 存在于 <code>map</code> 中，返回 <code>key</code> 对应的值，并将该节点移动到链表头部，表示其为最近使用的。</li><li>如果 <code>key</code> 不存在，返回 <code>-1</code>。</li></ul></li><li><p><strong><code>put</code> 操作</strong>：</p><ul><li>如果 <code>key</code> 已经存在，更新其值并将该节点移动到链表头部。</li><li>如果 <code>key</code> 不存在，插入新节点到链表头部，并将 <code>key</code> 和节点映射存储到 <code>map</code> 中。如果插入操作导致超出容量，则删除链表尾部的节点（即最久未使用的节点），并从 <code>map</code> 中删除相应的 <code>key</code>。</li></ul></li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-comment">// 定义双向链表节点类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        LinkedNode pre;<br>        LinkedNode next;<br>        LinkedNode() &#123;&#125;<br>        LinkedNode(<span class="hljs-type">int</span> key_, <span class="hljs-type">int</span> val_) &#123;<br>            key = key_;<br>            val = val_;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> LinkedNode head;<br>    <span class="hljs-keyword">private</span> LinkedNode tail;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, LinkedNode&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedNode</span>();<br>        head.next = tail;<br>        tail.pre = head;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            moveToHead(node);<br>            <span class="hljs-keyword">return</span> node.val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            node.val = value;<br>            moveToHead(node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedNode</span>(key, value);<br>            map.put(key, node);<br>            addToHead(node);<br>            size++;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">tailNode</span> <span class="hljs-operator">=</span> removeTail();<br>                map.remove(tailNode.key);<br>                size--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助方法：将节点移动到链表头部</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(LinkedNode node)</span> &#123;<br>        removeNode(node);<br>        addToHead(node);<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助方法：从链表中移除节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(LinkedNode node)</span> &#123;<br>        node.pre.next = node.next;<br>        node.next.pre = node.pre;<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助方法：将节点添加到链表头部</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(LinkedNode node)</span> &#123;<br>        node.next = head.next;<br>        node.pre = head;<br>        head.next.pre = node;<br>        head.next = node;<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助方法：移除链表尾部节点</span><br>    <span class="hljs-keyword">private</span> LinkedNode <span class="hljs-title function_">removeTail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">LinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> tail.pre;<br>        removeNode(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(1) 对于 <code>get</code> 和 <code>put</code> 操作，我们都只进行哈希表的查找和双向链表的插入、删除操作，每个操作都是 O(1)。</li><li><strong>空间复杂度</strong>: O(capacity)，存储哈希表和双向链表所需的空间。</li></ul><h3 id="优化与注意事项"><a href="#优化与注意事项" class="headerlink" title="优化与注意事项"></a>优化与注意事项</h3><ul><li><strong>优化点</strong>: 在 <code>get</code> 和 <code>put</code> 操作中，我们都通过调用 <code>moveToHead</code> 方法来将节点移动到链表头部，从而保持最近使用的元素在头部。这种方式简化了代码逻辑。</li><li><strong>边界处理</strong>: 初始化时，<code>head</code> 和 <code>tail</code> 是哨兵节点，可以避免在处理链表时的边界条件判断（如 <code>null</code> 检查）。</li><li><strong>容量管理</strong>: 每次插入新节点后，需要检查当前容量是否超出限制，如果超出则删除链表尾部节点以保证容量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-12</title>
    <link href="/2024/08/11/hot100-12/"/>
    <url>/2024/08/11/hot100-12/</url>
    
    <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 <code>prices</code>，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code>。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题的核心思路是找到一个最低的买入价格，然后计算在此买入价格下的最大利润。遍历数组时，我们保持一个最低买入价格 <code>cost</code>，同时更新当前可能的最大利润 <code>ans</code>。</p><p>具体步骤如下：</p><ol><li>初始化两个变量 <code>cost</code> 和 <code>ans</code>，<code>cost</code> 用于记录历史最低的买入价格，初始值为 <code>Integer.MAX_VALUE</code>，<code>ans</code> 用于记录最大利润，初始值为 <code>0</code>。</li><li>遍历价格数组 <code>prices</code>：<ul><li>对于每个价格 <code>prices[i]</code>，更新最低买入价格 <code>cost</code>，<code>cost = Math.min(cost, prices[i])</code>。</li><li>计算当前可能的最大利润 <code>prices[i] - cost</code>，并更新 <code>ans</code>，<code>ans = Math.max(ans, prices[i] - cost)</code>。</li></ul></li><li>返回最终的 <code>ans</code>。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-comment">// 更新最低买入价格</span><br>            cost = Math.min(cost, prices[i]);<br>            <span class="hljs-comment">// 计算并更新最大利润</span><br>            ans = Math.max(ans, prices[i] - cost);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是价格数组的长度。我们只需要遍历数组一次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>如果数组是严格递减的（即每天的价格都低于前一天的价格），那么无法获取利润，返回 <code>0</code>。</li><li>通过维护一个历史最低买入价格 <code>cost</code> 和一个最大利润 <code>ans</code>，可以在一次遍历中找到最佳的买卖时机。</li><li>初始状态下，<code>cost</code> 被设置为一个非常大的值（<code>Integer.MAX_VALUE</code>），以确保第一次遍历时能够正确更新为第一个价格。</li></ul><h1 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a>124. 二叉树中的最大路径和</h1><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树的根节点 <code>root</code>，求出二叉树中的 <strong>最大路径和</strong>。路径被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中至多出现一次。路径至少包含一个节点，且不一定经过根节点。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用递归的方法来求解二叉树中的最大路径和。对于每个节点，我们需要考虑以下几种情况：</p><ol><li>该节点本身作为路径的一部分。</li><li>该节点与左子树路径的最大值相连。</li><li>该节点与右子树路径的最大值相连。</li><li>该节点与左右子树路径的最大值相连。</li></ol><p>对于每个节点，我们计算其能够贡献的最大路径和，更新全局的最大路径和 <code>maxPath</code>。</p><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol><li>初始化一个全局变量 <code>maxPath</code>，用于存储最大路径和，初始值为 <code>Integer.MIN_VALUE</code>。</li><li>定义一个递归函数 <code>recur</code>，返回值为当前节点可以提供的最大单分支路径和：<ul><li>如果当前节点为 <code>null</code>，返回 0。</li><li>递归计算左子树的最大路径和，若小于 0 则不计入路径和中。</li><li>递归计算右子树的最大路径和，若小于 0 则不计入路径和中。</li><li>更新全局最大路径和 <code>maxPath</code> 为当前节点加上左右子树的路径和。</li><li>返回当前节点能提供给父节点的最大路径和，即 <code>当前节点值 + max(左子树路径和, 右子树路径和)</code>。</li></ul></li><li>递归遍历整棵树，最终返回 <code>maxPath</code>。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxPath</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        recur(root);<br>        <span class="hljs-keyword">return</span> maxPath;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 计算左子树的最大路径和，若为负数则忽略</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, recur(root.left));<br>        <span class="hljs-comment">// 计算右子树的最大路径和，若为负数则忽略</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, recur(root.right));<br>        <span class="hljs-comment">// 更新全局最大路径和为当前节点加上左右子树路径和</span><br>        maxPath = Math.max(maxPath, left + right + root.val);<br>        <span class="hljs-comment">// 返回当前节点能提供的最大单分支路径和</span><br>        <span class="hljs-keyword">return</span> Math.max(left, right) + root.val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是二叉树的节点数。每个节点只被访问一次。</li><li><strong>空间复杂度</strong>: O(h)，其中 <code>h</code> 是二叉树的高度。递归调用栈的深度等于树的高度，在最坏情况下（树是单链状），空间复杂度为 O(n)。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在递归过程中，确保当左右子树路径和为负时，不将其计入路径和中，这可以通过 <code>Math.max(0, recur(root.left))</code> 和 <code>Math.max(0, recur(root.right))</code> 来实现。</li><li>对于每个节点，考虑其作为路径中的一个节点时的最大贡献值，并更新全局最大路径和 <code>maxPath</code>。</li><li>最终返回的 <code>maxPath</code> 是整个二叉树的最大路径和，不一定必须经过根节点。</li></ul><h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h1><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">https://leetcode.cn/problems/longest-consecutive-sequence/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个未排序的整数数组 <code>nums</code>，找出数字连续的最长序列的长度。要求时间复杂度为 O(n)。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>要解决这个问题，我们可以使用一个哈希集合（<code>Set</code>）来存储数组中的所有元素，并通过遍历集合来查找最长的连续序列。具体步骤如下：</p><ol><li><strong>初始化哈希集合</strong>: 将数组 <code>nums</code> 中的所有元素加入到一个 <code>Set</code> 中。这一步的时间复杂度是 O(n)。</li><li><strong>遍历集合</strong>: 遍历集合中的每个元素 <code>num</code>，判断是否存在 <code>num - 1</code>。如果不存在，则以 <code>num</code> 作为起点，查找 <code>num</code> 开始的最长连续序列。</li><li><strong>查找最长序列</strong>: 如果当前数字 <code>num</code> 是一个序列的起点（即 <code>num - 1</code> 不存在），则继续查找 <code>num + 1</code>, <code>num + 2</code>, … 是否存在于集合中，并统计当前序列的长度。</li><li><strong>更新最大长度</strong>: 每次找到一个序列后，更新当前最长序列的长度。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 将所有数字加入集合</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            set.add(num);<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">longestStreak</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历集合，寻找最长的连续序列，而不是遍历原来的数组，避免重复计算</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : set) &#123;<br>            <span class="hljs-comment">// 只有当 num 是序列的起点时，才计算长度</span><br>            <span class="hljs-keyword">if</span> (!set.contains(num - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">currentNum</span> <span class="hljs-operator">=</span> num;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">currentStreak</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">// 查找从 num 开始的最长序列</span><br>                <span class="hljs-keyword">while</span> (set.contains(currentNum + <span class="hljs-number">1</span>)) &#123;<br>                    currentNum++;<br>                    currentStreak++;<br>                &#125;<br><br>                <span class="hljs-comment">// 更新最长序列长度</span><br>                longestStreak = Math.max(longestStreak, currentStreak);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> longestStreak;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)。初始化哈希集合的时间复杂度是 O(n)，遍历集合的时间复杂度也是 O(n)，因为每个元素在最坏情况下只会被处理两次（一次查找起点，一次查找连续序列）。</li><li><strong>空间复杂度</strong>: O(n)。哈希集合的空间复杂度是 O(n)。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>避免不必要的重复计算</strong>: 在遍历集合时，如果 <code>num - 1</code> 存在于集合中，则 <code>num</code> 不会是某个序列的起点，因此可以跳过对 <code>num</code> 的处理。这避免了重复计算的情况，有效减少了时间浪费。</li><li><strong>处理空数组</strong>: 在算法开始时，先检查输入数组是否为空或长度为 0，如果是，直接返回 0，这是一个重要的边界条件。</li></ul><h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h1><p><a href="https://leetcode.cn/problems/single-number/description/">https://leetcode.cn/problems/single-number/description/</a></p><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个非空整数数组 <code>nums</code>，除了某个元素只出现一次以外，其余每个元素均出现两次。请找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了满足线性时间复杂度和常量空间的要求，我们可以利用位运算中的 <strong>异或操作</strong> (<code>^</code>) 来解决这个问题。</p><h4 id="异或操作的性质："><a href="#异或操作的性质：" class="headerlink" title="异或操作的性质："></a>异或操作的性质：</h4><ol><li>一个数与自己异或的结果是 <code>0</code>：<code>a ^ a = 0</code>。</li><li>一个数与 <code>0</code> 异或的结果是它自己：<code>a ^ 0 = a</code>。</li><li>异或操作满足交换律和结合律：<code>a ^ b ^ a = b</code>。</li></ol><p>基于上述性质，数组中所有成对出现的元素在进行异或操作后都会抵消为 <code>0</code>，最终剩下的就是那个只出现一次的元素。</p><h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><ol><li>初始化一个变量 <code>res</code>，用于存储异或的结果，初始值为 <code>0</code>。</li><li>遍历数组 <code>nums</code>，对每个元素进行异或操作，将结果存入 <code>res</code>。</li><li>最终，<code>res</code> 的值即为只出现一次的那个元素。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            res ^= num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是数组 <code>nums</code> 的长度。我们只需要遍历数组一次。</li><li><strong>空间复杂度</strong>: O(1)，算法只使用了常量级的额外空间。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>异或操作的特性</strong>: 利用异或的性质，可以在不借助额外数据结构的情况下有效地找出数组中唯一一个只出现一次的元素。</li><li><strong>算法的高效性</strong>: 该算法的时间复杂度为 O(n)，空间复杂度为 O(1)，满足题目要求。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-11</title>
    <link href="/2024/08/10/hot100-11/"/>
    <url>/2024/08/10/hot100-11/</url>
    
    <content type="html"><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">https://leetcode.cn/problems/binary-tree-level-order-traversal/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你二叉树的根节点 <code>root</code>，返回其节点值的层序遍历。层序遍历是逐层地从左到右访问所有节点。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用广度优先搜索（BFS）来实现二叉树的层序遍历。具体思路如下：</p><ol><li>初始化一个队列 <code>dq</code>，用于存储当前层的节点。</li><li>初始化一个结果列表 <code>ans</code>，用于存储每一层的节点值列表。</li><li>将根节点 <code>root</code> 入队。</li><li>当队列不为空时，重复以下操作：<ul><li>记录当前队列的长度 <code>n</code>，表示当前层的节点数。</li><li>初始化一个临时列表 <code>tmp</code>，用于存储当前层的节点值。</li><li>依次从队列中取出节点，将节点值加入 <code>tmp</code>，并将该节点的左、右子节点（如果存在）加入队列。</li><li>将 <code>tmp</code> 添加到结果列表 <code>ans</code> 中。</li></ul></li><li>返回结果列表 <code>ans</code>。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> ans;<br><br>        Deque&lt;TreeNode&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        dq.add(root);<br><br>        <span class="hljs-keyword">while</span> (!dq.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> dq.size();<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> dq.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) dq.add(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) dq.add(node.right);<br>                n--;<br>            &#125;<br>            ans.add(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是二叉树的节点数。我们需要访问每个节点一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储结果列表 <code>ans</code> 和队列 <code>dq</code>。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在遍历每一层时，使用队列的长度 <code>n</code> 来记录当前层的节点数，并通过循环逐个处理节点，确保正确地分层。</li><li>每层结束时，将该层的节点值列表 <code>tmp</code> 添加到结果列表 <code>ans</code> 中。</li></ul><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><p>目前的实现已经较为高效，空间复杂度为 O(n) 是不可避免的，因为需要存储所有节点的值。代码结构清晰、简洁，可以进一步优化代码可读性，例如将队列初始化和根节点检查放在一起，减少冗余代码。</p><p>另外一种优化方向是减少内存使用，例如通过在处理每一层时，直接在结果列表中添加新的列表，而不使用额外的临时列表 <code>tmp</code>。但这会增加代码的复杂度，影响可读性，因此不建议进行此优化。</p><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树 <code>root</code>，返回其最大深度。二叉树的最大深度是指从根节点到最远叶子节点的最长路径上的节点数。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>要计算二叉树的最大深度，我们可以使用递归的方法。最大深度可以通过以下步骤来计算：</p><ol><li>如果当前节点为 <code>null</code>，则返回深度 <code>0</code>。</li><li>否则，递归计算左子树和右子树的最大深度，取两者中的较大值，然后加上当前节点自身的深度 <code>1</code>。</li></ol><p>这种递归方法会遍历每个节点，计算出其子树的最大深度，并逐层向上返回最终的最大深度。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是二叉树的节点数。我们需要遍历每个节点一次。</li><li><strong>空间复杂度</strong>: O(h)，其中 <code>h</code> 是二叉树的高度。递归调用栈的深度等于树的高度，在最坏情况下（树是单链状），空间复杂度为 O(n)。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>递归的方法直观且易于理解，每次递归调用返回子树的最大深度，并通过 <code>Math.max</code> 函数获取左右子树中较大的深度。</li><li>空树的最大深度为 <code>0</code>，递归基条件即为空节点的情况。</li></ul><h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code>，其中 <code>preorder</code> 是二叉树的先序遍历，<code>inorder</code> 是同一棵树的中序遍历，要求构造二叉树并返回其根节点。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>要从先序遍历和中序遍历构造二叉树，我们需要利用二叉树的性质：</p><ol><li><strong>先序遍历</strong>的第一个节点是树的根节点。</li><li><strong>中序遍历</strong>中，根节点将树分为左子树和右子树。</li></ol><p>具体步骤如下：</p><ol><li>根据先序遍历的第一个元素确定树的根节点。</li><li>在中序遍历中找到根节点的位置，确定左子树和右子树的元素。</li><li>递归地对左子树和右子树进行相同的操作，构造子树。</li><li>使用一个哈希表 <code>map</code> 来存储中序遍历中每个元素的位置，以加快查找速度。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    Map&lt;Integer, Integer&gt; map;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 将中序遍历的元素值和对应索引存入哈希表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-comment">// 递归构建二叉树</span><br>        <span class="hljs-keyword">return</span> method(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span> &#123;<br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-comment">// 根节点的值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[preStart];<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br><br>        <span class="hljs-comment">// 在中序遍历中找到根节点的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(rootVal);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftTreeSize</span> <span class="hljs-operator">=</span> index - inStart;<br><br>        <span class="hljs-comment">// 构建左子树</span><br>        root.left = method(preorder, preStart + <span class="hljs-number">1</span>, preStart + leftTreeSize, inorder, inStart, index - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 构建右子树</span><br>        root.right = method(preorder, preStart + leftTreeSize + <span class="hljs-number">1</span>, preEnd, inorder, index + <span class="hljs-number">1</span>, inEnd);<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是二叉树的节点数。每个节点都被访问一次，哈希表的查找操作平均是 O(1)。</li><li><strong>空间复杂度</strong>: O(n)，用于存储递归调用栈和哈希表。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保递归的终止条件处理正确：当 <code>preStart &gt; preEnd</code> 或 <code>inStart &gt; inEnd</code> 时，返回 <code>null</code>。</li><li>哈希表 <code>map</code> 用于存储中序遍历中每个节点的索引，以加快查找根节点的位置。</li><li>在递归过程中，分别构建左子树和右子树，并将它们连接到当前的根节点上。</li></ul><h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h1><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你二叉树的根结点 <code>root</code>，请你将它展开为一个单链表。展开后的单链表应该同样使用 <code>TreeNode</code>，其中 <code>right</code> 子指针指向链表中下一个结点，而 <code>left</code> 子指针始终为 <code>null</code>。展开后的单链表应该与二叉树先序遍历顺序相同。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以通过递归的方法来将二叉树展开为单链表。由于展开后的单链表应该与二叉树的先序遍历顺序相同，我们可以反向进行操作，即从后序遍历的角度处理二叉树。具体步骤如下：</p><ol><li>初始化一个全局变量 <code>pre</code>，用于存储当前节点在展开后的链表中的下一个节点。</li><li>递归地展开右子树和左子树。</li><li>将当前节点的 <code>right</code> 指针指向 <code>pre</code>（即当前节点的下一个节点），将 <code>left</code> 指针置为 <code>null</code>。</li><li>更新 <code>pre</code> 为当前节点。</li><li>当递归到叶子节点时，<code>pre</code> 会被更新为该节点，之后的节点会逐步连接到 <code>pre</code> 的右侧，最终形成单链表。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 用于记录链表的下一个节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 递归展开右子树和左子树</span><br>        flatten(root.right);<br>        flatten(root.left);<br>        <br>        <span class="hljs-comment">// 将当前节点的右指针指向 pre，左指针置为 null</span><br>        root.right = pre;<br>        root.left = <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-comment">// 更新 pre 为当前节点</span><br>        pre = root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是二叉树的节点数。每个节点都会被访问一次。</li><li><strong>空间复杂度</strong>: O(h)，其中 <code>h</code> 是二叉树的高度。递归调用栈的深度等于树的高度，在最坏情况下（树是单链状），空间复杂度为 O(n)。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>由于我们使用了反向的后序遍历（先处理右子树，再处理左子树），可以确保在展开过程中，每个节点的右子树已经被正确展开并连接到链表中。</li><li>在递归过程中，我们始终将 <code>left</code> 指针置为 <code>null</code>，确保最终的二叉树完全展开为单链表。</li><li>初始状态下，<code>pre</code> 为 <code>null</code>，表示链表的尾部。在递归过程中，<code>pre</code> 不断向前更新，最终形成单链表。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过递归的方法，我们可以有效地将二叉树展开为符合先序遍历顺序的单链表。代码实现简单，结构清晰，时间和空间复杂度都在合理范围内。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-10</title>
    <link href="/2024/08/07/hot100-10/"/>
    <url>/2024/08/07/hot100-10/</url>
    
    <content type="html"><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">https://leetcode.cn/problems/binary-tree-inorder-traversal/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树的根节点 <code>root</code>，返回它的中序遍历。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>中序遍历的顺序是左子树 -&gt; 根节点 -&gt; 右子树。我们可以使用递归和迭代两种方法来实现中序遍历。</p><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><ol><li>初始化一个列表 <code>list</code> 用于存储遍历结果。</li><li>定义一个辅助函数 <code>inorder</code>，接受当前节点 <code>root</code> 和结果列表 <code>list</code> 作为参数。</li><li>在辅助函数中，如果当前节点 <code>root</code> 为空，则直接返回。</li><li>递归调用 <code>inorder</code> 函数遍历左子树。</li><li>将当前节点的值添加到结果列表 <code>list</code> 中。</li><li>递归调用 <code>inorder</code> 函数遍历右子树。</li><li>返回结果列表 <code>list</code>。</li></ol><h3 id="递归代码实现"><a href="#递归代码实现" class="headerlink" title="递归代码实现"></a>递归代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        inorder(list, root);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorder(list, root.left);<br>        list.add(root.val);<br>        inorder(list, root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ol><li>使用一个栈 <code>stack</code> 来辅助遍历。</li><li>初始化一个指针 <code>curr</code> 指向根节点 <code>root</code>。</li><li>循环以下操作直到 <code>curr</code> 为空且 <code>stack</code> 为空：<ul><li>将当前节点 <code>curr</code> 的所有左子节点依次入栈，并将 <code>curr</code> 指向其左子节点。</li><li>如果 <code>curr</code> 为空，从栈中弹出一个节点，将该节点的值添加到结果列表 <code>list</code> 中，并将 <code>curr</code> 指向该节点的右子节点。</li></ul></li><li>返回结果列表 <code>list</code>。</li></ol><h3 id="迭代代码实现"><a href="#迭代代码实现" class="headerlink" title="迭代代码实现"></a>迭代代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> root;<br><br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-comment">// 将当前节点的所有左子节点入栈</span><br>            <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(curr);<br>                curr = curr.left;<br>            &#125;<br>            <span class="hljs-comment">// 弹出栈顶节点，并将其值添加到结果列表中</span><br>            curr = stack.pop();<br>            list.add(curr.val);<br>            <span class="hljs-comment">// 转向右子树</span><br>            curr = curr.right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是二叉树的节点数。每个节点都被访问一次。</li><li><strong>空间复杂度</strong>:<ul><li>递归方法：O(h)，其中 <code>h</code> 是树的高度。递归调用栈的深度等于树的高度。</li><li>迭代方法：O(h)，其中 <code>h</code> 是树的高度。栈的最大深度等于树的高度。</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在递归方法中，注意在访问节点时先递归遍历左子树，再处理当前节点，最后递归遍历右子树。</li><li>在迭代方法中，注意使用栈来模拟递归过程，确保正确的遍历顺序。</li></ul><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h1><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">https://leetcode.cn/problems/unique-binary-search-trees/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数 <code>n</code>，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的二叉搜索树有多少种？返回满足题意的二叉搜索树的种数。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。设 <code>dp[i]</code> 表示 <code>i</code> 个节点组成的二叉搜索树的种数。对于一个二叉搜索树，其根节点可以是 <code>1</code> 到 <code>i</code> 中的任意一个节点。假设以 <code>j</code> 为根节点，那么左子树的节点个数为 <code>j-1</code>，右子树的节点个数为 <code>i-j</code>。</p><p>状态转移方程为：<br>[ dp[i] &#x3D; \sum_{j&#x3D;1}^{i} dp[j-1] \times dp[i-j] ]</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化动态规划数组 <code>dp</code>，大小为 <code>n+1</code>，其中 <code>dp[0] = 1</code>，表示空树的种数为 1。</li><li>遍历从 <code>1</code> 到 <code>n</code> 的每个节点数 <code>i</code>，对于每个 <code>i</code>：<ul><li>遍历从 <code>1</code> 到 <code>i</code> 的每个根节点 <code>j</code>，计算左子树和右子树的种数，并累加到 <code>dp[i]</code> 中。</li></ul></li><li>最后返回 <code>dp[n]</code> 作为结果。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 动态规划数组</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 计算每个节点数 i 的二叉搜索树种数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n^2)，其中 <code>n</code> 是节点的个数。我们需要填充 <code>dp</code> 数组，其中每个 <code>dp[i]</code> 需要进行 <code>i</code> 次累加计算。</li><li><strong>空间复杂度</strong>: O(n)，用于存储动态规划数组 <code>dp</code>。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>动态规划数组 <code>dp</code> 的初始化非常重要，特别是 <code>dp[0] = 1</code>，表示空树的种数为 1。</li><li>状态转移方程的推导需要理解二叉搜索树的性质，即每个节点作为根节点时，左子树和右子树的节点数是确定的。</li><li>确保在代码实现中，正确处理数组索引和边界条件。</li></ul><h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">https://leetcode.cn/problems/validate-binary-search-tree/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p>有效二叉搜索树定义如下：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以通过中序遍历来验证二叉搜索树的有效性。中序遍历二叉搜索树时，节点的值应该是严格递增的。因此，我们可以通过中序遍历判断每个节点的值是否满足条件。</p><p>具体步骤如下：</p><ol><li>初始化一个 <code>TreeNode</code> 变量 <code>pre</code>，用于存储中序遍历过程中上一个节点的值。</li><li>定义一个辅助函数 <code>inorder</code>，接受当前节点 <code>root</code> 作为参数。</li><li>在 <code>inorder</code> 函数中：<ul><li>如果当前节点 <code>root</code> 为空，返回 <code>true</code>。</li><li>递归调用 <code>inorder</code> 函数遍历左子树，如果左子树不是有效的二叉搜索树，返回 <code>false</code>。</li><li>如果当前节点的值小于等于 <code>pre</code> 节点的值，返回 <code>false</code>。</li><li>更新 <code>pre</code> 为当前节点。</li><li>递归调用 <code>inorder</code> 函数遍历右子树，并返回结果。</li></ul></li><li>返回中序遍历结果。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    TreeNode pre;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> inorder(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-keyword">if</span> (!inorder(root.left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 检查当前节点是否满足二叉搜索树的条件</span><br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.val &gt;= root.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 更新 pre 为当前节点</span><br>        pre = root;<br><br>        <span class="hljs-comment">// 递归遍历右子树</span><br>        <span class="hljs-keyword">return</span> inorder(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是二叉树的节点数。每个节点都被访问一次。</li><li><strong>空间复杂度</strong>: O(h)，其中 <code>h</code> 是二叉树的高度。递归调用栈的深度等于树的高度。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>中序遍历时，确保每个节点的值严格递增，才能判断为有效的二叉搜索树。</li><li>辅助函数 <code>inorder</code> 的递归调用需要检查左子树和右子树是否满足二叉搜索树的条件。</li><li>初始化 <code>pre</code> 变量为 <code>null</code>，在中序遍历过程中更新 <code>pre</code> 为上一个节点。</li></ul><h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/description/">https://leetcode.cn/problems/symmetric-tree/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二叉树的根节点 <code>root</code>，检查它是否轴对称。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>轴对称的二叉树定义如下：</p><ul><li>根节点的左子树和右子树是镜像对称的。</li></ul><p>为了检查二叉树是否轴对称，我们可以使用递归的方法。具体来说，定义一个辅助函数 <code>isEqual</code>，用于比较两个子树是否是镜像对称的。如果两个子树是镜像对称的，那么：</p><ol><li>它们的根节点值相等。</li><li>一个子树的左子树与另一个子树的右子树是镜像对称的。</li><li>一个子树的右子树与另一个子树的左子树是镜像对称的。</li></ol><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>检查根节点 <code>root</code> 是否为空。如果为空，则树是对称的，返回 <code>true</code>。</li><li>否则，调用辅助函数 <code>isEqual</code> 比较根节点的左子树和右子树是否镜像对称。</li><li>在 <code>isEqual</code> 函数中：<ul><li>如果两个子树都为空，返回 <code>true</code>。</li><li>如果一个子树为空，另一个子树不为空，或者两个子树的根节点值不相等，返回 <code>false</code>。</li><li>递归比较两个子树的左子树与右子树，以及右子树与左子树是否镜像对称。</li></ul></li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> root == <span class="hljs-literal">null</span> || isEqual(root.left, root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEqual</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span> || left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> isEqual(left.left, right.right) &amp;&amp; isEqual(left.right, right.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是二叉树的节点数。我们需要遍历每个节点来检查对称性。</li><li><strong>空间复杂度</strong>: O(h)，其中 <code>h</code> 是二叉树的高度。递归调用栈的深度等于树的高度。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>辅助函数 <code>isEqual</code> 递归地检查两个子树是否镜像对称。</li><li>特别注意空节点的处理：两个子树都为空时，它们是对称的；如果只有一个子树为空，另一个不为空，则它们不对称。</li><li>递归比较两个子树的左子树与右子树，以及右子树与左子树，确保镜像对称性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-9</title>
    <link href="/2024/08/06/hot100-9/"/>
    <url>/2024/08/06/hot100-9/</url>
    
    <content type="html"><![CDATA[<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h1><p><a href="https://leetcode.cn/problems/subsets/description/">https://leetcode.cn/problems/subsets/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code>，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。你可以按任意顺序返回解集。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来生成所有可能的子集。回溯算法可以动态地构建子集，并在每个递归步骤中决定是否包含当前元素，从而生成所有可能的组合。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化结果列表 <code>list</code> 和路径列表 <code>path</code>。</li><li>定义一个回溯函数 <code>backtracking</code>，它接受一个起始索引 <code>startIndex</code> 和数组 <code>nums</code> 作为参数。</li><li>在每个递归步骤中，将当前路径列表 <code>path</code> 添加到结果列表 <code>list</code> 中。</li><li>遍历数组 <code>nums</code>，从起始索引 <code>startIndex</code> 开始，对于每个元素：<ul><li>将当前元素添加到路径列表 <code>path</code> 中。</li><li>递归调用 <code>backtracking</code>，传递下一个起始索引 <code>i + 1</code>。</li><li>递归返回后，从路径列表 <code>path</code> 中移除最后一个元素，以便于继续生成其他子集。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; list;<br>    List&lt;Integer&gt; path;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtracking(<span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 将当前路径添加到结果列表中</span><br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br><br>        <span class="hljs-comment">// 遍历数组，从起始索引开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 添加当前元素到路径列表</span><br>            path.add(nums[i]);<br>            <span class="hljs-comment">// 递归调用，传递下一个起始索引</span><br>            backtracking(i + <span class="hljs-number">1</span>, nums);<br>            <span class="hljs-comment">// 从路径列表中移除最后一个元素</span><br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n * 2^n)，其中 <code>n</code> 是数组 <code>nums</code> 的长度。每个元素有两种选择（包含或不包含），共有 <code>2^n</code> 个子集，每个子集的平均长度为 <code>n/2</code>。</li><li><strong>空间复杂度</strong>: O(n)，用于存储递归调用栈和路径列表 <code>path</code>。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>回溯算法的核心在于递归地构建子集，并在每个递归步骤中决定是否包含当前元素。</li><li>确保在每次递归调用后，从路径列表 <code>path</code> 中移除最后一个元素，以便于继续生成其他子集。</li><li>将当前路径列表 <code>path</code> 添加到结果列表 <code>list</code> 中时，注意创建 <code>path</code> 的副本，以避免后续修改影响结果。</li></ul><h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h1><p><a href="https://leetcode.cn/problems/word-search/description/">https://leetcode.cn/problems/word-search/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 <code>m x n</code> 的二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code>。如果 <code>word</code> 存在于网格中，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用深度优先搜索（DFS）来解决这个问题。具体步骤如下：</p><ol><li>初始化一个二维布尔数组 <code>flag</code> 来记录每个单元格是否已被使用。</li><li>遍历网格中的每个单元格作为起始点，如果当前单元格的字符与 <code>word</code> 的第一个字符匹配，则调用 DFS 函数进行搜索。</li><li>在 DFS 函数中：<ul><li>如果当前匹配的字符数 <code>n</code> 等于 <code>word</code> 的长度，说明找到完整匹配，返回 <code>true</code>。</li><li>遍历四个方向的相邻单元格，如果相邻单元格的字符与 <code>word</code> 的下一个字符匹配，且该单元格未被使用，则继续递归搜索。</li><li>如果找到匹配，返回 <code>true</code>，否则将该单元格标记为未使用，继续搜索其他方向。</li></ul></li><li>如果遍历完所有单元格都未找到匹配，返回 <code>false</code>。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] dir = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 用于表示四个方向的移动</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br><br>        <span class="hljs-comment">// 遍历每个单元格作为起始点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == word.charAt(<span class="hljs-number">0</span>)) &#123; <span class="hljs-comment">// 如果当前字符匹配 word 的第一个字符</span><br>                    flag[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (dfs(board, <span class="hljs-number">1</span>, word, i, j, flag)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    flag[i][j] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 回溯</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> n, String word, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">boolean</span>[][] flag)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == word.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 完全匹配</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i += <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 遍历四个方向</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextX</span> <span class="hljs-operator">=</span> dir[i] + x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextY</span> <span class="hljs-operator">=</span> dir[i + <span class="hljs-number">1</span>] + y;<br>            <span class="hljs-keyword">if</span> (nextX &lt; <span class="hljs-number">0</span> || nextX &gt;= board.length || nextY &lt; <span class="hljs-number">0</span> || nextY &gt;= board[<span class="hljs-number">0</span>].length || flag[nextX][nextY] || word.charAt(n) != board[nextX][nextY]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            flag[nextX][nextY] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (dfs(board, n + <span class="hljs-number">1</span>, word, nextX, nextY, flag)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            flag[nextX][nextY] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m * n * 4^l)，其中 <code>m</code> 和 <code>n</code> 分别是网格的行数和列数，<code>l</code> 是字符串 <code>word</code> 的长度。最坏情况下，每个单元格都要进行一次深度优先搜索，每次搜索最多有 4 个方向。</li><li><strong>空间复杂度</strong>: O(m * n)，用于存储布尔数组 <code>flag</code> 和递归调用栈。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>递归函数中通过遍历四个方向来进行搜索，每次搜索前标记当前单元格为已使用，搜索结束后回溯。</li><li>如果找到匹配，立即返回 <code>true</code>，否则继续搜索其他方向。</li><li>如果遍历完所有单元格都未找到匹配，返回 <code>false</code>。</li></ul><h1 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h1><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">https://leetcode.cn/problems/largest-rectangle-in-histogram/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 <code>n</code> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code>。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用单调栈来解决这个问题。单调栈可以帮助我们快速找到每个柱子左右两边第一个小于当前高度的柱子，从而确定当前柱子的最大矩形面积。</p><p>具体步骤如下：</p><ol><li>创建一个新的数组 <code>tmp</code>，在 <code>heights</code> 数组的左右各添加一个高度为 <code>0</code> 的哨兵，确保所有柱子都能被处理到。</li><li>使用单调栈 <code>dq</code> 来存储柱子的索引，保持栈内元素递增。</li><li>遍历 <code>tmp</code> 数组：<ul><li>如果当前柱子的高度小于栈顶柱子的高度，说明找到了一个以栈顶柱子为高的矩形区域，计算其面积，并更新最大面积。</li><li>将当前柱子的索引压入栈中。</li></ul></li><li>遍历结束后，返回最大面积。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-comment">// 创建一个新的数组，左右各添加一个高度为 0 的哨兵</span><br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[heights.length + <span class="hljs-number">2</span>];<br>        System.arraycopy(heights, <span class="hljs-number">0</span>, tmp, <span class="hljs-number">1</span>, heights.length);<br>        <br>        <span class="hljs-comment">// 单调栈，保持递增</span><br>        Deque&lt;Integer&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 遍历新数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tmp.length; i++) &#123;<br>            <span class="hljs-comment">// 当前值小于栈顶值，找到一个以栈顶柱子为高的矩形区域</span><br>            <span class="hljs-keyword">while</span> (!dq.isEmpty() &amp;&amp; tmp[i] &lt; tmp[dq.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> tmp[dq.pop()];<br>                result = Math.max(result, (i - dq.peek() - <span class="hljs-number">1</span>) * h);<br>            &#125;<br>            <span class="hljs-comment">// 将当前索引压入栈中</span><br>            dq.push(i);<br>        &#125;        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是柱子的数量。我们只需遍历数组一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储新的数组和单调栈。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用哨兵元素可以简化边界条件的处理，确保所有柱子都能被处理到。</li><li>单调栈用于存储柱子的索引，保持栈内元素递增，以便于快速找到每个柱子左右两边第一个小于当前高度的柱子。</li><li>在计算矩形面积时，需要注意矩形的宽度为当前索引 <code>i</code> 减去栈顶索引减 1。</li></ul><h3 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h3><ol><li>初始化带哨兵的数组 <code>tmp</code> 和单调栈 <code>dq</code>。</li><li>遍历 <code>tmp</code> 数组，使用单调栈记录柱子的索引，确保栈内元素递增。</li><li>当当前柱子的高度小于栈顶柱子的高度时，计算以栈顶柱子为高的矩形区域的面积，并更新最大面积。</li><li>遍历结束后，返回最大面积。</li></ol><h1 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a>85. 最大矩形</h1><p><a href="https://leetcode.cn/problems/maximal-rectangle/description/">https://leetcode.cn/problems/maximal-rectangle/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个仅包含 0 和 1、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以将问题转化为多个柱状图中最大矩形面积的问题。具体来说，将矩阵的每一行看作是一个底，将每一列的高度看作是连续的 1 的数量。对于每一行，我们计算其对应的高度，然后使用单调栈来计算最大矩形面积。</p><p>步骤如下：</p><ol><li>初始化一个高度数组 <code>tmp</code>，其长度为 <code>cols + 2</code>，并在左右各添加一个哨兵。</li><li>遍历矩阵的每一行，更新高度数组 <code>tmp</code>：<ul><li>如果当前元素为 ‘0’，则将对应高度置为 0。</li><li>如果当前元素为 ‘1’，则将对应高度加 1。</li></ul></li><li>对每一行更新后的高度数组 <code>tmp</code>，使用单调栈计算最大矩形面积：<ul><li>使用单调栈存储柱状图的索引，保持栈内元素递增。</li><li>如果当前高度小于栈顶元素高度，则计算以栈顶元素为高的矩形面积，并更新最大面积。</li></ul></li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalRectangle</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[matrix[<span class="hljs-number">0</span>].length + <span class="hljs-number">2</span>]; <span class="hljs-comment">// 高度数组，左右各添加一个哨兵</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; matrix[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-comment">// 更新高度数组</span><br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                    tmp[j + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tmp[j + <span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 使用单调栈计算最大矩形面积</span><br>            Deque&lt;Integer&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; tmp.length; j++) &#123;<br>                <span class="hljs-keyword">while</span> (!dq.isEmpty() &amp;&amp; tmp[dq.peek()] &gt; tmp[j]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> tmp[dq.pop()];<br>                    result = Math.max(result, (j - dq.peek() - <span class="hljs-number">1</span>) * h);<br>                &#125;<br>                dq.push(j);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(rows * cols)，其中 <code>rows</code> 和 <code>cols</code> 分别是矩阵的行数和列数。我们需要遍历每一行，每行遍历的时间复杂度为 O(cols)。</li><li><strong>空间复杂度</strong>: O(cols)，用于存储高度数组 <code>tmp</code> 和单调栈。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>高度数组 <code>tmp</code> 的长度为 <code>cols + 2</code>，并在左右各添加一个哨兵，确保所有柱子都能被处理到。</li><li>在更新高度数组时，如果当前元素为 ‘0’，高度置为 0；如果为 ‘1’，高度加 1。</li><li>使用单调栈来计算最大矩形面积，确保栈内元素递增，以便于快速找到左右边界。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-8</title>
    <link href="/2024/08/05/hot100-8/"/>
    <url>/2024/08/05/hot100-8/</url>
    
    <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h1><p><a href="https://leetcode.cn/problems/climbing-stairs/description/">https://leetcode.cn/problems/climbing-stairs/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。问有多少种不同的方法可以爬到楼顶？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。设 <code>dp[i]</code> 表示爬到第 <code>i</code> 阶的方法数。由于每次只能爬 <code>1</code> 或 <code>2</code> 个台阶，爬到第 <code>i</code> 阶的方法数可以由以下两部分组成：</p><ol><li>从第 <code>i-1</code> 阶爬 <code>1</code> 个台阶到达第 <code>i</code> 阶。</li><li>从第 <code>i-2</code> 阶爬 <code>2</code> 个台阶到达第 <code>i</code> 阶。</li></ol><p>因此，状态转移方程为：<br>[ dp[i] &#x3D; dp[i-1] + dp[i-2] ]</p><p>初始条件为：</p><ul><li>爬到第 <code>0</code> 阶的方法数为 <code>1</code>（不动）。</li><li>爬到第 <code>1</code> 阶的方法数为 <code>1</code>（一步）。</li></ul><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个大小为 <code>n+1</code> 的数组 <code>dp</code>，其中 <code>dp[i]</code> 表示爬到第 <code>i</code> 阶的方法数。</li><li>设置初始条件：<code>dp[0] = 1</code>，<code>dp[1] = 1</code>。</li><li>遍历从 <code>2</code> 到 <code>n</code> 的每个阶梯，计算 <code>dp[i]</code>：<ul><li><code>dp[i] = dp[i-1] + dp[i-2]</code></li></ul></li><li>返回 <code>dp[n]</code> 作为结果。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n; <br>        <span class="hljs-comment">// 动态规划数组，dp[i] 表示爬到第 i 阶的方法数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 计算 dp 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是阶梯的总数。我们需要遍历每个阶梯一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储动态规划数组 <code>dp</code>。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>初始条件 <code>dp[0] = 1</code> 和 <code>dp[1] = 1</code> 是基础，表示从地面到第 <code>1</code> 阶的方法数。</li><li>状态转移方程 <code>dp[i] = dp[i-1] + dp[i-2]</code> 表示每次可以选择爬 <code>1</code> 阶或 <code>2</code> 阶到达第 <code>i</code> 阶。</li><li>确保在代码实现中，遍历的范围和数组索引的正确性。</li></ul><h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h1><p><a href="https://leetcode.cn/problems/edit-distance/description/">https://leetcode.cn/problems/edit-distance/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数。你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。设 <code>dp[i][j]</code> 表示将 <code>word1</code> 的前 <code>i</code> 个字符转换为 <code>word2</code> 的前 <code>j</code> 个字符所需的最少操作数。</p><p>具体步骤如下：</p><ol><li>初始化动态规划数组 <code>dp</code>，大小为 <code>(m+1) x (n+1)</code>，其中 <code>m</code> 和 <code>n</code> 分别是 <code>word1</code> 和 <code>word2</code> 的长度。</li><li>初始化 <code>dp[i][0]</code> 为 <code>i</code>，表示将 <code>word1</code> 的前 <code>i</code> 个字符转换为空字符串所需的操作数（全部删除）。</li><li>初始化 <code>dp[0][j]</code> 为 <code>j</code>，表示将空字符串转换为 <code>word2</code> 的前 <code>j</code> 个字符所需的操作数（全部插入）。</li><li>遍历每个字符，填充动态规划数组 <code>dp</code>：<ul><li>如果 <code>word1[i-1] == word2[j-1]</code>，则 <code>dp[i][j] = dp[i-1][j-1]</code>。</li><li>否则，<code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code>，分别表示替换、删除和插入操作。</li></ul></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-comment">// 填充 dp 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m * n)，其中 <code>m</code> 和 <code>n</code> 分别是 <code>word1</code> 和 <code>word2</code> 的长度。我们需要遍历所有的字符对来填充动态规划数组。</li><li><strong>空间复杂度</strong>: O(m * n)，用于存储动态规划数组 <code>dp</code>。</li></ul><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>我们可以进一步优化空间复杂度。因为在计算 <code>dp[i][j]</code> 时，只需要 <code>dp[i-1][j-1]</code>、<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code>，所以可以使用两个一维数组 <code>prev</code> 和 <code>curr</code> 代替二维数组 <code>dp</code>。</p><h3 id="优化后的代码实现"><a href="#优化后的代码实现" class="headerlink" title="优化后的代码实现"></a>优化后的代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-type">int</span>[] prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] curr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            prev[j] = j;<br>        &#125;<br><br>        <span class="hljs-comment">// 填充 dp 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            curr[<span class="hljs-number">0</span>] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    curr[j] = prev[j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    curr[j] = Math.min(prev[j - <span class="hljs-number">1</span>], Math.min(prev[j], curr[j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 更新 prev 数组</span><br>            <span class="hljs-type">int</span>[] temp = prev;<br>            prev = curr;<br>            curr = temp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> prev[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化后的复杂度分析"><a href="#优化后的复杂度分析" class="headerlink" title="优化后的复杂度分析"></a>优化后的复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m * n)，与之前相同。</li><li><strong>空间复杂度</strong>: O(n)，只使用了两个一维数组 <code>prev</code> 和 <code>curr</code>。</li></ul><h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h1><p><a href="https://leetcode.cn/problems/sort-colors/description/">https://leetcode.cn/problems/sort-colors/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色的顺序排列。我们使用整数 <code>0</code>、<code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。要求在不使用库内置的 <code>sort</code> 函数的情况下解决这个问题。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用双指针法来解决这个问题，通过两个指针将数组划分为三部分：红色（0）、白色（1）和蓝色（2）。</p><p>具体步骤如下：</p><ol><li>初始化两个指针 <code>p0</code> 和 <code>p2</code>，分别指向数组的开始和结束位置，用于交换 0 和 2。</li><li>使用一个指针 <code>i</code> 遍历数组：<ul><li>如果 <code>nums[i]</code> 等于 2，则将其与 <code>p2</code> 位置的元素交换，并将 <code>p2</code> 向左移动一位。</li><li>如果 <code>nums[i]</code> 等于 0，则将其与 <code>p0</code> 位置的元素交换，并将 <code>p0</code> 向右移动一位。</li><li>如果 <code>nums[i]</code> 等于 1，则继续遍历。</li></ul></li></ol><p>通过这种方式，数组可以被原地排序为红色、白色和蓝色。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p2 = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= p2; i++) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; p2 &amp;&amp; nums[i] == <span class="hljs-number">2</span>) &#123;<br>                nums[i] = nums[p2];<br>                nums[p2] = <span class="hljs-number">2</span>;<br>                p2--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                nums[i] = nums[p0];<br>                nums[p0] = <span class="hljs-number">0</span>;<br>                p0++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是数组的长度。我们只需遍历数组一次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用双指针 <code>p0</code> 和 <code>p2</code>，分别指向数组的开始和结束位置，通过交换元素实现原地排序。</li><li>遍历数组时，如果遇到 2，将其与 <code>p2</code> 位置的元素交换，并将 <code>p2</code> 向左移动一位。</li><li>如果遇到 0，将其与 <code>p0</code> 位置的元素交换，并将 <code>p0</code> 向右移动一位。</li><li>遇到 1 时，直接跳过，继续遍历。</li></ul><h1 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h1><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/">https://leetcode.cn/problems/minimum-window-substring/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>s</code> 和一个字符串 <code>t</code>。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code>。</p><p>注意：</p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用滑动窗口和哈希表来解决这个问题。具体步骤如下：</p><ol><li>初始化两个指针 <code>left</code> 和 <code>right</code>，表示滑动窗口的左右边界。初始化一个哈希表 <code>map</code>，记录 <code>t</code> 中每个字符的数量。</li><li>移动 <code>right</code> 指针扩大窗口，直到窗口包含 <code>t</code> 中所有字符。</li><li>移动 <code>left</code> 指针缩小窗口，直到窗口不能再缩小，记录当前最小窗口。</li><li>重复步骤 2 和 3，直到 <code>right</code> 指针到达字符串 <code>s</code> 的末尾。</li><li>返回记录的最小窗口。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br>        <span class="hljs-keyword">if</span> (m &lt; n) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 存放最短的前后指针</span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>, m&#125;;<br>        <span class="hljs-comment">// 哈希表存 t 中字符的个数</span><br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 双指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; m) &#123;<br>            <span class="hljs-comment">// 右指针右移</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(s.charAt(right))) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> map.get(s.charAt(right));<br>                map.put(s.charAt(right), num - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>                    count--;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 总数减为0时，左指针右移找最小</span><br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>                    <span class="hljs-keyword">if</span> (map.containsKey(s.charAt(left))) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> map.get(s.charAt(left));<br>                        map.put(s.charAt(left), num + <span class="hljs-number">1</span>);<br>                        <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-comment">// 找到最小</span><br>                            count++;<br>                            <span class="hljs-keyword">if</span> ((arr[<span class="hljs-number">1</span>] - arr[<span class="hljs-number">0</span>]) &gt; (right - left)) &#123;<br>                                arr[<span class="hljs-number">0</span>] = left;<br>                                arr[<span class="hljs-number">1</span>] = right;<br>                            &#125;<br>                            left++;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    left++;<br>                &#125;<br>            &#125;<br>            right++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">1</span>] - arr[<span class="hljs-number">0</span>] == m) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s.substring(arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m + n)，其中 m 是字符串 <code>s</code> 的长度，n 是字符串 <code>t</code> 的长度。遍历 <code>s</code> 和 <code>t</code> 各一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储 <code>t</code> 中字符的哈希表。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用滑动窗口和哈希表来记录字符及其数量。</li><li>移动 <code>right</code> 指针扩大窗口，直到窗口包含 <code>t</code> 中所有字符。</li><li>移动 <code>left</code> 指针缩小窗口，找到最小覆盖子串。</li><li>如果找不到符合条件的子串，返回空字符串 <code>&quot;&quot;</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-7</title>
    <link href="/2024/08/05/hot100-7/"/>
    <url>/2024/08/05/hot100-7/</url>
    
    <content type="html"><![CDATA[<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h1><p><a href="https://leetcode.cn/problems/jump-game/submissions/552558014/">https://leetcode.cn/problems/jump-game/submissions/552558014/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个非负整数数组 <code>nums</code>，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code>；否则，返回 <code>false</code>。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用贪心算法来解决这个问题。贪心算法的核心是不断更新能够到达的最远位置，并判断这个位置是否覆盖到数组的最后一个下标。</p><p>具体步骤如下：</p><ol><li>初始化一个变量 <code>distance</code>，表示当前能够到达的最远位置。</li><li>遍历数组 <code>nums</code>，对于每个元素 <code>nums[i]</code>：<ul><li>如果当前下标 <code>i</code> 大于 <code>distance</code>，说明不能再往前跳，直接返回 <code>false</code>。</li><li>更新 <code>distance</code> 为 <code>max(distance, i + nums[i])</code>，即考虑当前位置能跳跃的最远距离。</li><li>如果 <code>distance</code> 已经覆盖到数组的最后一个下标，返回 <code>true</code>。</li></ul></li><li>遍历结束后，如果 <code>distance</code> 仍然没有覆盖到最后一个下标，返回 <code>false</code>。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= distance; i++) &#123;<br>            <span class="hljs-comment">// 更新能够到达的最远位置</span><br>            distance = Math.max(distance, i + nums[i]);<br>            <span class="hljs-comment">// 判断是否已经能够到达最后一个下标</span><br>            <span class="hljs-keyword">if</span> (distance &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是数组的长度。我们只需遍历一次数组。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>贪心算法的核心在于不断更新能够到达的最远位置，并判断这个位置是否覆盖到数组的最后一个下标。</li><li>如果当前下标 <code>i</code> 大于 <code>distance</code>，说明不能再往前跳，直接返回 <code>false</code>。</li><li>初始化时，<code>distance</code> 变量设置为 0，表示从第一个下标开始跳跃。</li></ul><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h1><p><a href="https://leetcode.cn/problems/merge-intervals/description/">https://leetcode.cn/problems/merge-intervals/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start_i, end_i]</code>。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以按照起始位置对区间进行排序，然后遍历排序后的区间，合并重叠的区间。具体步骤如下：</p><ol><li>对区间数组按照起始位置进行排序，如果起始位置相同，则按结束位置排序。</li><li>遍历排序后的区间数组，使用一个变量 <code>currentInterval</code> 表示当前处理的区间：<ul><li>如果当前区间的结束位置 <code>currentInterval[1]</code> 大于等于下一个区间的起始位置 <code>sortedIntervals[i][0]</code>，说明有重叠，将当前区间的结束位置更新为两个区间结束位置的最大值。</li><li>如果没有重叠，则将 <code>currentInterval</code> 添加到结果列表中，并将当前区间更新为下一个区间。</li></ul></li><li>遍历结束后，将最后一个区间添加到结果列表中。</li><li>返回结果列表。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-comment">// 排序，首先按起始位置排序，如果起始位置相同，则按结束位置排序</span><br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b)</span> &#123;<br>                <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br><br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] currentInterval = intervals[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (currentInterval[<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-comment">// 有重叠，合并区间</span><br>                currentInterval[<span class="hljs-number">1</span>] = Math.max(currentInterval[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 没有重叠，添加前一个区间到列表并更新当前区间</span><br>                list.add(currentInterval);<br>                currentInterval = intervals[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加最后一个区间</span><br>        list.add(currentInterval);<br><br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n log n)，其中 n 是区间的数量。排序的时间复杂度为 O(n log n)，遍历区间的时间复杂度为 O(n)。</li><li><strong>空间复杂度</strong>: O(n)，用于存储结果列表和排序后的区间数组。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要对区间数组进行排序，以便于后续的合并操作。</li><li>在合并区间时，始终保持当前处理的区间，并更新其结束位置。</li><li>确保遍历结束后将最后一个区间添加到结果列表中，避免遗漏。</li></ul><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/description/">https://leetcode.cn/problems/unique-paths/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点标记为 “Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（标记为 “Finish”）。问总共有多少条不同的路径？</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。设 <code>dp[i][j]</code> 表示从起点到达位置 <code>(i, j)</code> 的路径数量。由于机器人只能向下或者向右移动，因此路径数量的状态转移方程为：</p><p>$$<br>dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]<br>$$</p><p>其中，<code>dp[i-1][j]</code> 表示从上方到达 <code>(i, j)</code> 的路径数量，<code>dp[i][j-1]</code> 表示从左方到达 <code>(i, j)</code> 的路径数量。</p><p>为了优化空间复杂度，我们可以使用一维数组 <code>dp</code> 来存储路径数量。每次更新 <code>dp[j]</code> 时，只需要 <code>dp[j]</code> 和 <code>dp[j-1]</code> 的值即可。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一维数组 <code>dp</code>，大小为 <code>n</code>，并设置 <code>dp[0] = 1</code>，表示从起点到第一列的路径数量。</li><li>遍历网格的每一行 <code>i</code>，对于每一行中的每一列 <code>j</code>，更新 <code>dp[j]</code>：<ul><li><code>dp[j] = dp[j] + dp[j-1]</code>，表示当前格子的路径数量等于上方格子和左方格子的路径数量之和。</li></ul></li><li>最后返回 <code>dp[n-1]</code>，即到达右下角的路径数量。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 初始化一维数组 dp</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 动态规划更新路径数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[j] = dp[j] + dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m * n)，其中 m 和 n 分别是网格的行数和列数。我们需要遍历整个网格进行动态规划更新。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是网格的列数。我们只使用了一维数组 <code>dp</code> 来存储路径数量。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>动态规划数组 <code>dp</code> 只需要初始化第一列的值，其他位置通过状态转移方程更新。</li><li>在每次更新 <code>dp[j]</code> 时，考虑的是当前格子上方和左方格子的路径数量之和。</li><li>使用一维数组优化空间复杂度，确保代码简洁高效。</li></ul><h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h1><p><a href="https://leetcode.cn/problems/minimum-path-sum/description/">https://leetcode.cn/problems/minimum-path-sum/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code>，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。我们使用一个一维数组 <code>dp</code> 来存储到达每个位置的最小路径和。</p><p>具体步骤如下：</p><ol><li>初始化一维数组 <code>dp</code>，大小为 <code>n</code>（网格的列数）。<code>dp[j]</code> 表示到达位置 <code>(i, j)</code> 的最小路径和。</li><li>初始化 <code>dp[0]</code> 为 <code>grid[0][0]</code>，表示从起点到第一个位置的路径和。</li><li>初始化 <code>dp</code> 数组的第一行，表示从起点到第一行每个位置的路径和。</li><li>遍历网格的每一行 <code>i</code>，对于每一行中的每一列 <code>j</code>，更新 <code>dp[j]</code>：<ul><li>如果 <code>j == 0</code>，表示在第一列，只能从上方移动下来，因此 <code>dp[j] = grid[i][j] + dp[j]</code>。</li><li>否则，<code>dp[j]</code> 取决于从左方或者从上方移动过来的最小路径和，即 <code>dp[j] = Math.min(dp[j-1], dp[j]) + grid[i][j]</code>。</li></ul></li><li>最后返回 <code>dp[n-1]</code>，即到达右下角的最小路径和。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">// 校验输入</span><br>        <span class="hljs-keyword">if</span> (grid == <span class="hljs-literal">null</span> || grid.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>        <span class="hljs-comment">// 初始化dp数组的第一行</span><br>        dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i] = grid[<span class="hljs-number">0</span>][i] + dp[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历每一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                    dp[j] = grid[i][j] + dp[j]; <span class="hljs-comment">// 第一列只能从上方移动下来</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[j] = Math.min(dp[j - <span class="hljs-number">1</span>], dp[j]) + grid[i][j]; <span class="hljs-comment">// 从左方或上方移动过来</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(m * n)，其中 m 和 n 分别是网格的行数和列数。我们需要遍历整个网格进行动态规划更新。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是网格的列数。我们只使用了一维数组 <code>dp</code> 来存储路径和。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在遍历过程中，确保每个位置的路径和都是从上方或左方的最小路径和加上当前位置的值。</li><li>初始化 <code>dp</code> 数组的第一行，确保从起点到第一行每个位置的路径和正确。</li><li>在更新 <code>dp</code> 数组时，注意处理第一列的特殊情况，只能从上方移动下来。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-6</title>
    <link href="/2024/07/31/hot100-6/"/>
    <url>/2024/07/31/hot100-6/</url>
    
    <content type="html"><![CDATA[<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h1><p><a href="https://leetcode.cn/problems/permutations/description/">https://leetcode.cn/problems/permutations/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列。你可以按任意顺序返回答案。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来解决这个问题。回溯算法可以动态地构建所有可能的排列，并在满足条件时保存结果。具体步骤如下：</p><ol><li>初始化结果列表 <code>list</code> 和当前路径 <code>path</code>。</li><li>使用一个标志数组 <code>flag</code> 来记录每个数字是否已被使用。</li><li>定义一个回溯函数 <code>backtracking</code>，用于构建所有可能的排列：<ul><li>如果当前路径 <code>path</code> 的长度等于数组 <code>nums</code> 的长度，表示找到一个完整的排列，将其添加到结果列表 <code>list</code> 中。</li><li>否则，遍历数组 <code>nums</code>：<ul><li>如果当前数字已被使用，跳过。</li><li>将当前数字添加到路径 <code>path</code> 中，并标记为已使用。</li><li>递归调用 <code>backtracking</code> 继续构建排列。</li><li>递归返回后，移除路径 <code>path</code> 中的最后一个元素，并取消标记。</li></ul></li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; list;<br>    List&lt;Integer&gt; path;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list;<br>        <span class="hljs-type">boolean</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtracking(nums, flag);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] flag)</span> &#123;<br>        <span class="hljs-comment">// 如果当前路径长度等于数组长度，保存当前排列</span><br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 如果当前数字已被使用，跳过</span><br>            <span class="hljs-keyword">if</span> (flag[i]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 添加当前数字到路径中，并标记为已使用</span><br>            path.add(nums[i]);<br>            flag[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 递归构建下一个排列</span><br>            backtracking(nums, flag);<br>            <span class="hljs-comment">// 移除路径中的最后一个元素，并取消标记</span><br>            flag[i] = <span class="hljs-literal">false</span>;<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n!)，其中 n 是数组 <code>nums</code> 的长度。全排列的数量为 n!，每个排列的构建过程需要 O(n) 的时间。</li><li><strong>空间复杂度</strong>: O(n)，递归调用的最大深度为 n，另外需要 O(n) 的空间来存储临时的排列结果和标志数组。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用标志数组 <code>flag</code> 来记录每个数字是否已被使用，避免重复使用。</li><li>在每次找到一个完整排列时，创建当前路径 <code>path</code> 的副本，并添加到结果列表 <code>list</code> 中。</li><li>在递归返回后，及时移除路径中的最后一个元素，并取消标志，确保其他排列的构建不受影响。</li></ul><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h1><p><a href="https://leetcode.cn/problems/rotate-image/description/">https://leetcode.cn/problems/rotate-image/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 <code>n × n</code> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了在原地旋转矩阵，我们可以将矩阵分层处理，每次将四个角上的元素进行交换。具体步骤如下：</p><ol><li>将矩阵按照层进行处理，每一层将对应的四个位置的元素进行交换。</li><li>对于第 <code>i</code> 层的第 <code>j</code> 个元素 <code>matrix[i][i+j]</code>，它需要移动到 <code>matrix[i+j][n-i-1]</code>，即右侧。</li><li>依次将四个位置的元素进行交换，直到所有层都处理完毕。</li></ol><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>遍历每一层，范围是从 0 到 <code>n/2</code>。</li><li>对于每一层，遍历该层中的元素，范围是从 0 到 <code>n-i*2-1</code>。</li><li>对于每一个元素，进行四次交换：<ul><li>将 <code>matrix[i][i+j]</code> 移动到 <code>matrix[i+j][n-i-1]</code>。</li><li>将 <code>matrix[n-i-1-j][i]</code> 移动到 <code>matrix[i][i+j]</code>。</li><li>将 <code>matrix[n-i-1][n-i-1-j]</code> 移动到 <code>matrix[n-i-1-j][i]</code>。</li><li>将 <code>matrix[i+j][n-i-1]</code> 移动到 <code>matrix[n-i-1][n-i-1-j]</code>。</li></ul></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 遍历每一层</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 遍历每层中的元素</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][i + j];<br>                <span class="hljs-comment">// 将左下角的元素移到左上角</span><br>                matrix[i][i + j] = matrix[n - i - <span class="hljs-number">1</span> - j][i];<br>                <span class="hljs-comment">// 将右下角的元素移到左下角</span><br>                matrix[n - i - <span class="hljs-number">1</span> - j][i] = matrix[n - i - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span> - j];<br>                <span class="hljs-comment">// 将右上角的元素移到右下角</span><br>                matrix[n - i - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span> - j] = matrix[i + j][n - i - <span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// 将临时变量中的元素（原左上角）移到右上角</span><br>                matrix[i + j][n - i - <span class="hljs-number">1</span>] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n^2)，其中 n 是矩阵的边长。我们需要遍历矩阵中的每一个元素进行交换。</li><li><strong>空间复杂度</strong>: O(1)，我们只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保在遍历每一层时，不要越界。</li><li>注意每次交换四个位置的顺序，确保每个元素都正确移动到其新位置。</li><li>直接在输入的二维矩阵上进行操作，不要使用额外的矩阵。</li></ul><h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h1><p><a href="https://leetcode.cn/problems/group-anagrams/description/">https://leetcode.cn/problems/group-anagrams/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词是由重新排列源单词的所有字母得到的一个新单词。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用哈希表来解决这个问题。对于每个字符串，将其字符排序后作为键，将所有具有相同排序结果的字符串分组到一起。</p><p>具体步骤如下：</p><ol><li>初始化一个哈希表 <code>map</code>，键为排序后的字符串，值为字母异位词列表。</li><li>遍历字符串数组 <code>strs</code>：<ul><li>将每个字符串转换为字符数组并排序。</li><li>将排序后的字符数组转换为字符串作为键。</li><li>将原字符串添加到对应键的列表中。</li></ul></li><li>返回哈希表中所有值的列表，即所有字母异位词的分组。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-comment">// 初始化哈希表</span><br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 遍历字符串数组</span><br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-comment">// 将字符串转换为字符数组并排序</span><br>            <span class="hljs-type">char</span>[] arr = str.toCharArray();<br>            Arrays.sort(arr);<br>            <span class="hljs-comment">// 将排序后的字符数组转换为字符串</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">newLetter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr);<br>            <span class="hljs-comment">// 获取哈希表中对应键的列表，没有则创建新列表</span><br>            List&lt;String&gt; list = map.getOrDefault(newLetter, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            <span class="hljs-comment">// 将原字符串添加到列表中</span><br>            list.add(str);<br>            <span class="hljs-comment">// 将列表存入哈希表</span><br>            map.put(newLetter, list);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回哈希表中所有值的列表</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n * k * log k)，其中 n 是字符串数组的长度，k 是字符串的最大长度。对每个字符串排序的时间复杂度为 O(k * log k)，遍历字符串数组的时间复杂度为 O(n)。</li><li><strong>空间复杂度</strong>: O(n * k)，其中 n 是字符串数组的长度，k 是字符串的最大长度。用于存储哈希表和字符数组。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>字符排序后的结果作为哈希表的键，可以唯一地标识字母异位词。</li><li>使用 <code>Arrays.sort</code> 对字符数组进行排序，并将排序后的字符数组转换为字符串，保证能够正确分组字母异位词。</li><li>最终返回哈希表中所有值的列表，即所有字母异位词的分组。</li></ul><h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h1><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">https://leetcode.cn/problems/maximum-subarray/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划来解决这个问题。动态规划可以帮助我们在遍历数组的过程中，找到以每个元素结尾的最大子数组和，从而得到整个数组的最大子数组和。</p><p>具体步骤如下：</p><ol><li>初始化两个变量 <code>pre</code> 和 <code>ans</code>。<code>pre</code> 表示以当前元素结尾的最大子数组和，<code>ans</code> 表示全局最大子数组和。</li><li>遍历数组 <code>nums</code>，对于每个元素 <code>nums[i]</code>：<ul><li>更新 <code>pre</code> 为 <code>max(nums[i], pre + nums[i])</code>，即以当前元素结尾的最大子数组和。</li><li>更新 <code>ans</code> 为 <code>max(ans, pre)</code>，即全局最大子数组和。</li></ul></li><li>返回 <code>ans</code> 作为结果。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化为数组的第一个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 计算以当前元素结尾的最大子数组和</span><br>            pre = Math.max(nums[i], pre + nums[i]);<br>            <span class="hljs-comment">// 更新全局最大子数组和</span><br>            ans = Math.max(ans, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是数组的长度。我们只需遍历一次数组。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>动态规划的核心在于找到以每个元素结尾的最大子数组和，并在过程中更新全局最大子数组和。</li><li>初始化 <code>ans</code> 为数组的第一个元素，确保在数组只有一个元素时也能正确返回结果。</li><li>在遍历过程中，及时更新 <code>pre</code> 和 <code>ans</code>，确保能够得到全局最大子数组和。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-5</title>
    <link href="/2024/07/30/hot100-5/"/>
    <url>/2024/07/30/hot100-5/</url>
    
    <content type="html"><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">https://leetcode.cn/problems/search-in-rotated-sorted-array/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值互不相同。在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（0 &lt;&#x3D; k &lt; nums.length）上进行了旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标从 0 开始计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>。</p><p>给你旋转后的数组 <code>nums</code> 和一个整数 <code>target</code>，如果 <code>nums</code> 中存在这个目标值 <code>target</code>，则返回它的下标，否则返回 -1。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用二分查找算法来解决这个问题。通过二分查找，我们可以在 O(log n) 的时间复杂度内找到目标值。在旋转数组中，至少有一半是有序的，通过判断哪一半有序，可以确定目标值是否在有序部分，从而决定搜索的范围。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化两个指针 <code>left</code> 和 <code>right</code>，分别指向数组的左右两端。</li><li>进行二分查找，直到 <code>left</code> 超过 <code>right</code>：<ul><li>计算中间位置 <code>mid</code>。</li><li>如果 <code>nums[mid]</code> 等于目标值 <code>target</code>，直接返回 <code>mid</code>。</li><li>判断哪一半是有序的：<ul><li>如果 <code>nums[mid]</code> 到 <code>nums[right]</code> 是有序的：<ul><li>判断目标值 <code>target</code> 是否在这个有序范围内：<ul><li>如果是，则继续在右半部分进行二分查找。</li><li>否则，在左半部分进行二分查找。</li></ul></li></ul></li><li>如果 <code>nums[left]</code> 到 <code>nums[mid]</code> 是有序的：<ul><li>判断目标值 <code>target</code> 是否在这个有序范围内：<ul><li>如果是，则继续在左半部分进行二分查找。</li><li>否则，在右半部分进行二分查找。</li></ul></li></ul></li></ul></li></ul></li><li>如果没有找到目标值，返回 -1。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 初始化左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 二分查找</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br><br>            <span class="hljs-comment">// 如果中间值等于目标值，返回中间值的索引</span><br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断哪一半是有序的</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[right]) &#123;<br>                <span class="hljs-comment">// 右半部分有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<br>                    left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 在右半部分查找</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 在左半部分查找</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 左半部分有序</span><br>                <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                    right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 在左半部分查找</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 在右半部分查找</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果没有找到目标值，返回 -1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(log n)，因为使用了二分查找算法。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>要特别注意边界条件的判断，确保二分查找的范围正确。</li><li>判断哪一半是有序的，可以通过比较 <code>nums[mid]</code> 与 <code>nums[right]</code> 或 <code>nums[mid]</code> 与 <code>nums[left]</code> 来进行。</li><li>处理旋转数组的关键是利用二分查找的特性，通过判断哪一半是有序的来缩小查找范围。</li></ul><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用二分查找来找到目标值在数组中的开始位置和结束位置。首先，我们需要找到目标值的左边界，然后再找到右边界。</p><ol><li><p>使用二分查找找到目标值的左边界：</p><ul><li>初始化 <code>left</code> 为 0，<code>right</code> 为数组长度。</li><li>在循环中，计算中间位置 <code>mid</code>。</li><li>如果 <code>nums[mid]</code> 小于目标值 <code>target</code>，则将 <code>left</code> 移动到 <code>mid + 1</code>。</li><li>否则，将 <code>right</code> 移动到 <code>mid</code>。</li><li>循环结束后，如果 <code>nums[left]</code> 不等于 <code>target</code>，说明数组中不存在目标值，返回 <code>[-1, -1]</code>。</li><li>否则，记录左边界位置。</li></ul></li><li><p>使用二分查找找到目标值的右边界：</p><ul><li>初始化 <code>right</code> 为数组长度。</li><li>在循环中，计算中间位置 <code>mid</code>。</li><li>如果 <code>nums[mid]</code> 小于等于目标值 <code>target</code>，则将 <code>left</code> 移动到 <code>mid + 1</code>。</li><li>否则，将 <code>right</code> 移动到 <code>mid</code>。</li><li>循环结束后，记录右边界位置为 <code>right - 1</code>。</li></ul></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 初始化结果数组</span><br>        <span class="hljs-type">int</span>[] ans = &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-comment">// 边界条件处理</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span> || nums[<span class="hljs-number">0</span>] &gt; target || nums[nums.length - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">return</span> ans;<br><br>        <span class="hljs-comment">// 二分查找左边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查左边界是否存在目标值</span><br>        <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target) <span class="hljs-keyword">return</span> ans;<br>        ans[<span class="hljs-number">0</span>] = left;<br><br>        <span class="hljs-comment">// 二分查找右边界</span><br>        right = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        ans[<span class="hljs-number">1</span>] = right - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(log n)，其中 n 是数组的长度。二分查找的时间复杂度为 O(log n)。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>二分查找的左右边界初始化为数组的开始和结束位置。</li><li>找左边界时，确保找到的第一个等于目标值的索引。</li><li>找右边界时，确保找到的最后一个等于目标值的索引。</li><li>检查左边界是否存在目标值，以避免数组中不存在目标值时返回错误结果。</li></ul><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p><a href="https://leetcode.cn/problems/combination-sum/description/">https://leetcode.cn/problems/combination-sum/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个无重复元素的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code>，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有不同组合，并以列表形式返回。你可以按任意顺序返回这些组合。</p><p><code>candidates</code> 中的同一个数字可以无限制重复被选取。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 150 个。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来解决这个问题。回溯算法可以动态地构建所有可能的组合，并在满足条件时保存结果。具体步骤如下：</p><ol><li>初始化结果列表 <code>list</code> 和当前路径 <code>path</code>。</li><li>对 <code>candidates</code> 数组进行排序，这样可以提前结束不必要的递归。</li><li>定义一个回溯函数 <code>backtracking</code>，用于构建和为 <code>target</code> 的所有组合：<ul><li>如果当前和 <code>sum</code> 等于 <code>target</code>，将当前路径 <code>path</code> 添加到结果列表 <code>list</code> 中。</li><li>否则，遍历 <code>candidates</code> 数组，从当前索引 <code>startIndex</code> 开始，避免重复组合。</li><li>如果当前和 <code>sum</code> 加上 <code>candidates[i]</code> 大于 <code>target</code>，则提前结束递归。</li><li>否则，将 <code>candidates[i]</code> 添加到当前路径 <code>path</code> 中，并递归调用 <code>backtracking</code> 继续构建组合。</li><li>递归返回后，移除当前路径 <code>path</code> 中的最后一个元素，继续探索其他组合。</li></ul></li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; list;<br>    List&lt;Integer&gt; path;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (candidates == <span class="hljs-literal">null</span> || candidates.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list;<br>        Arrays.sort(candidates);<br>        <span class="hljs-keyword">if</span> (candidates[<span class="hljs-number">0</span>] &gt; target) <span class="hljs-keyword">return</span> list;<br>        backtracking(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-comment">// 如果当前和等于目标值，保存当前组合</span><br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历候选数组，从当前索引开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-comment">// 如果当前和加上候选数大于目标值，提前结束递归</span><br>            <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) <span class="hljs-keyword">return</span>;<br>            <br>            <span class="hljs-comment">// 添加当前候选数到路径中</span><br>            path.add(candidates[i]);<br>            <span class="hljs-comment">// 递归构建下一个组合，允许重复使用当前候选数</span><br>            backtracking(candidates, target, sum + candidates[i], i);<br>            <span class="hljs-comment">// 移除路径中的最后一个元素，探索其他组合</span><br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: 取决于目标值 <code>target</code> 和 <code>candidates</code> 数组的大小。在最坏情况下，每个元素都可能被选取多次，因此复杂度接近于指数级别，具体取决于问题的输入和输出规模。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是目标值 <code>target</code>。递归调用的最大深度与目标值 <code>target</code> 成正比。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>由于可以无限次使用 <code>candidates</code> 中的元素，递归时要传入当前索引 <code>startIndex</code>，以避免生成重复组合。</li><li>对 <code>candidates</code> 数组进行排序，可以在递归过程中提前结束不必要的递归，提高算法效率。</li><li>每次找到一个和为 <code>target</code> 的组合时，都需要将当前路径 <code>path</code> 的一个副本添加到结果列表 <code>list</code> 中，以避免引用问题。</li></ul><h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h1><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">https://leetcode.cn/problems/trapping-rain-water/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用单调栈来解决这个问题。单调栈可以帮助我们快速找到左边和右边的较高柱子，从而计算出当前柱子能接的雨水量。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个栈 <code>st</code> 和一个变量 <code>sum</code> 来存储接到的雨水总量。</li><li>遍历高度数组 <code>height</code>：<ul><li>如果当前高度 <code>height[current]</code> 大于栈顶元素的高度，说明形成了一个凹槽，可以接到雨水。</li><li>弹出栈顶元素，作为凹槽的底部高度 <code>h</code>。</li><li>如果栈为空，说明没有左边界，不能形成凹槽，跳出循环。</li><li>计算左边界和当前高度之间的距离 <code>distance</code> 和较低的高度 <code>min</code>。</li><li>计算当前凹槽能接到的雨水量，并累加到总量 <code>sum</code> 中。</li><li>将当前索引 <code>current</code> 压入栈中。</li></ul></li><li>返回接到的雨水总量 <code>sum</code>。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 初始化接雨水总量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 使用单调栈</span><br>        ArrayDeque&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">// 当前遍历索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历高度数组</span><br>        <span class="hljs-keyword">while</span> (current &lt; height.length) &#123;<br>            <span class="hljs-comment">// 当栈不为空且当前高度大于栈顶高度时</span><br>            <span class="hljs-keyword">while</span> (!st.isEmpty() &amp;&amp; height[current] &gt; height[st.peek()]) &#123;<br>                <span class="hljs-comment">// 弹出栈顶元素，作为凹槽的底部高度</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> height[st.peek()];<br>                st.poll();<br>                <span class="hljs-comment">// 如果栈为空，跳出循环</span><br>                <span class="hljs-keyword">if</span> (st.isEmpty()) <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-comment">// 计算左边界和当前高度之间的距离</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> current - st.peek() - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 计算较低的高度</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(height[st.peek()], height[current]);<br>                <span class="hljs-comment">// 计算当前凹槽能接到的雨水量，并累加到总量</span><br>                sum = sum + distance * (min - h);<br>            &#125;<br>            <span class="hljs-comment">// 将当前索引压入栈中</span><br>            st.push(current);<br>            <span class="hljs-comment">// 移动到下一个柱子</span><br>            current++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是高度数组的长度。每个元素最多被栈操作一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储栈中的元素。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>单调栈用于记录柱子的索引，而不是高度值。</li><li>当栈为空时，说明没有左边界，无法形成凹槽接雨水。</li><li>计算凹槽的雨水量时，注意 <code>distance</code> 和 <code>min</code> 的计算方法，确保准确计算每个凹槽的雨水量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-4</title>
    <link href="/2024/07/30/hot100-4/"/>
    <url>/2024/07/30/hot100-4/</url>
    
    <content type="html"><![CDATA[<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h1><p><a href="https://leetcode.cn/problems/generate-parentheses/description/">https://leetcode.cn/problems/generate-parentheses/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于生成所有可能的并且有效的括号组合。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来生成所有可能的括号组合。在构建括号组合的过程中，我们需要确保生成的括号序列始终有效。具体来说，任意前缀中左括号的数量必须大于或等于右括号的数量。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个结果列表 <code>ans</code> 用于存储所有有效的括号组合，并使用一个 <code>StringBuilder</code> 对象 <code>sb</code> 来构建当前的括号序列。</li><li>定义一个回溯函数 <code>backtracking</code>，它接受两个参数：剩余的左括号数量 <code>left</code> 和剩余的右括号数量 <code>right</code>。</li><li>在回溯函数中：<ul><li>如果左右括号数量都为0，说明当前构建的括号序列是有效的，将其加入结果列表 <code>ans</code> 中。</li><li>如果还有左括号可以使用，则添加一个左括号，并递归调用回溯函数。</li><li>如果右括号数量大于左括号数量，则添加一个右括号，并递归调用回溯函数。</li><li>在递归返回之前，撤销上一步的选择，即从 <code>sb</code> 中删除最后一个字符。</li></ul></li><li>调用回溯函数开始生成所有可能的括号组合。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 结果列表</span><br>    List&lt;String&gt; ans;<br>    <span class="hljs-comment">// 用于构建当前括号序列</span><br>    StringBuilder sb;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 初始化结果列表</span><br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始化 StringBuilder</span><br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// 开始回溯</span><br>        backtracking(n, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 如果左右括号数量都为 0，添加当前序列到结果列表</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>            ans.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果还有左括号可以使用，添加一个左括号并递归</span><br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            backtracking(left - <span class="hljs-number">1</span>, right);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果右括号数量大于左括号数量，添加一个右括号并递归</span><br>        <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; left &lt; right) &#123;<br>            sb.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            backtracking(left, right - <span class="hljs-number">1</span>);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(4^n &#x2F; √n)，生成所有可能的括号组合数量为卡特兰数，这里的时间复杂度是卡特兰数的上界。</li><li><strong>空间复杂度</strong>: O(n)，递归的深度最大为 <code>2n</code>，每次递归调用使用的空间为 O(1)。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在构建括号序列时，必须确保右括号的数量始终不大于左括号的数量。</li><li>使用 <code>StringBuilder</code> 来构建当前的括号序列，避免多次字符串拼接的开销。</li><li>在递归返回之前，撤销上一步的选择，以确保构建其他可能的组合时不受影响。</li></ul><h1 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a>23. 合并 K 个升序链表</h1><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">https://leetcode.cn/problems/merge-k-sorted-lists/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用最小堆（优先队列）来合并 <code>k</code> 个已排序的链表。最小堆能够在 O(log k) 的时间复杂度内获取和删除最小元素，使我们可以高效地找到所有链表中当前最小的节点。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个最小堆 <code>PriorityQueue</code>，用来存储每个链表的节点。堆的大小为 <code>k</code>。</li><li>将每个链表的第一个节点加入最小堆。</li><li>创建一个哨兵节点 <code>dummy</code> 作为合并后链表的头节点，并初始化一个指针 <code>pre</code> 指向哨兵节点。</li><li>不断从最小堆中取出当前最小的节点，将其加入合并后的链表中，并将指针 <code>pre</code> 移动到新加入的节点。</li><li>如果被取出的节点还有下一个节点，则将下一个节点加入最小堆。</li><li>当最小堆为空时，合并完成，返回哨兵节点的下一个节点作为合并后的链表的头节点。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-comment">// 如果链表数组为空或长度为0，直接返回null</span><br>        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 创建一个长度为k的最小堆</span><br>        PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(lists.length, (a, b) -&gt; Integer.compare(a.val, b.val));<br><br>        <span class="hljs-comment">// 将每个链表的第一个节点加入最小堆</span><br>        <span class="hljs-keyword">for</span> (ListNode list : lists) &#123;<br>            <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span>) &#123;<br>                pq.offer(list);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建哨兵节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br><br>        <span class="hljs-comment">// 不断从最小堆中取出当前最小的节点，将其加入合并后的链表中</span><br>        <span class="hljs-keyword">while</span> (pq.peek() != <span class="hljs-literal">null</span>) &#123;<br>            pre.next = pq.poll();<br>            pre = pre.next;<br>            <span class="hljs-comment">// 如果被取出的节点还有下一个节点，将下一个节点加入最小堆</span><br>            <span class="hljs-keyword">if</span> (pre.next != <span class="hljs-literal">null</span>) &#123;<br>                pq.offer(pre.next);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回哨兵节点的下一个节点作为合并后的链表的头节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(N log k)，其中 N 是所有链表中节点的总数，k 是链表的数量。每次插入和删除操作的时间复杂度为 O(log k)，总共进行 N 次操作。</li><li><strong>空间复杂度</strong>: O(k)，用于存储最小堆中最多 k 个节点。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要处理输入为空或长度为 0 的情况，直接返回 null。</li><li>使用最小堆可以高效地合并多个已排序的链表，每次操作的时间复杂度为 O(log k)。</li><li>哨兵节点可以简化链表操作，避免处理头节点为空的特殊情况。</li></ul><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><p><a href="https://leetcode.cn/problems/next-permutation/description/">https://leetcode.cn/problems/next-permutation/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>整数数组的一个排列就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr &#x3D; [1,2,3]，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]。<br>整数数组的下一个排列是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的下一个排列就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2]。类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2]。而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3]，因为 [3,2,1] 不存在一个字典序更大的排列。</p><p>给你一个整数数组 <code>nums</code>，找出 <code>nums</code> 的下一个排列。必须原地修改，只允许使用额外常数空间。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>要找到下一个字典序更大的排列，我们可以按以下步骤操作：</p><ol><li>从后向前查找第一个相邻升序对 <code>(i-1, i)</code>，满足 <code>nums[i-1] &lt; nums[i]</code>。这样可以确定需要调整的部分。</li><li>在从右往左找到的第一个升序对中，找出右侧部分中比 <code>nums[i-1]</code> 大的最小元素，并交换它们。</li><li>将右侧部分从 <code>i</code> 开始的元素逆序排列，以得到最小的字典序。</li></ol><h3 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>从数组末尾向前查找第一个 <code>nums[i-1] &lt; nums[i]</code> 的位置 <code>i-1</code>。</li><li>如果找到了这样的 <code>i-1</code>，则在 <code>i</code> 到末尾之间查找比 <code>nums[i-1]</code> 大的最小元素 <code>nums[j]</code>，交换 <code>nums[i-1]</code> 和 <code>nums[j]</code>。</li><li>将位置 <code>i</code> 到末尾的部分进行反转，使其变成最小字典序。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 特殊情况处理</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br><br>        <span class="hljs-comment">// 从后向前查找第一个升序对</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果找到了升序对</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 从后向前找比 nums[i] 大的最小元素</span><br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span> (j = len - <span class="hljs-number">1</span>; j &gt; i; j--) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 交换 nums[i] 和 nums[j]</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = tmp;<br>        &#125;<br><br>        <span class="hljs-comment">// 反转 i 之后的部分</span><br>        reverse(nums, i + <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[start];<br>            nums[start] = nums[end];<br>            nums[end] = tmp;<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是数组的长度。最坏情况下需要遍历数组三次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>从后向前查找第一个升序对 <code>(i-1, i)</code>，确保找到的调整位置是字典序最小的。</li><li>交换元素时，确保选择的是比 <code>nums[i-1]</code> 大的最小元素，以获得下一个更大的排列。</li><li>最后一步的反转操作是为了将调整位置后的部分变成最小字典序，从而确保整体排列是下一个字典序更大的排列。</li></ul><h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h1><p><a href="https://leetcode.cn/problems/longest-valid-parentheses/description/">https://leetcode.cn/problems/longest-valid-parentheses/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用动态规划的方法来解决这个问题。我们定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以索引 <code>i</code> 结尾的最长有效括号子串的长度。</p><h3 id="详细步骤-3"><a href="#详细步骤-3" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个 <code>dp</code> 数组，长度与字符串 <code>s</code> 相同，初始值都为 0。</li><li>遍历字符串 <code>s</code>，从索引 1 开始：<ul><li>如果 <code>s[i]</code> 是 ‘)’ 并且前一个字符 <code>s[i-1]</code> 是 ‘(‘，则我们找到了一对有效括号：<ul><li><code>dp[i] = dp[i-2] + 2</code>，这里 <code>dp[i-2]</code> 是在当前这对有效括号之前的最长有效括号子串的长度。</li></ul></li><li>如果 <code>s[i]</code> 是 ‘)’ 并且前一个字符 <code>s[i-1]</code> 是 ‘)’，则我们需要检查 <code>s[i-dp[i-1]-1]</code> 是否是 ‘(‘：<ul><li>如果是，则 <code>dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2</code>，其中 <code>dp[i-1]</code> 是前一个位置的最长有效括号子串长度，<code>dp[i-dp[i-1]-2]</code> 是在当前有效子串之前的最长有效括号子串的长度。</li></ul></li></ul></li><li>更新 <code>maxLength</code> 为 <code>dp[i]</code> 中的最大值。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 初始化最大长度为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 动态规划数组</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br><br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 如果当前字符是&#x27;)&#x27;</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 检查前一个字符是否是&#x27;(&#x27;</span><br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <br>                <span class="hljs-comment">// 如果前一个字符是&#x27;)&#x27;，并且在前一个有效括号子串之前有一个&#x27;(&#x27;</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + ((i - dp[i - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-comment">// 更新最大长度</span><br>                maxLength = Math.max(maxLength, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是字符串的长度。我们只需遍历字符串一次。</li><li><strong>空间复杂度</strong>: O(n)，用于存储动态规划数组 <code>dp</code>。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>动态规划数组 <code>dp</code> 用于存储以每个索引结尾的最长有效括号子串的长度。</li><li>在计算 <code>dp[i]</code> 时，需要根据当前字符和前一个字符的不同情况进行不同的处理。</li><li><code>maxLength</code> 记录了遍历过程中找到的最长有效括号子串的长度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-3</title>
    <link href="/2024/07/30/hot100-3/"/>
    <url>/2024/07/30/hot100-3/</url>
    
    <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以使用回溯算法来解决这个问题。回溯算法能够在构建解决方案的过程中动态地撤销已经做出的选择，从而可以探索所有可能的组合。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个映射数组 <code>lettermap</code>，将数字与其对应的字母关联起来。</li><li>初始化结果列表 <code>ans</code> 和一个用于构建组合的 <code>StringBuilder</code> 对象 <code>sb</code>。</li><li>如果输入的字符串为空，直接返回空列表。</li><li>使用回溯函数 <code>backtracking</code> 来生成所有可能的组合：<ul><li>如果当前索引等于输入字符串的长度，表示已经生成了一个完整的组合，将其加入结果列表。</li><li>否则，获取当前数字对应的字母集，然后依次尝试每个字母，并递归调用 <code>backtracking</code> 生成下一层的组合。</li><li>在递归返回之前，撤销上一步的选择，即从 <code>sb</code> 中删除最后一个字符。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] lettermap =&#123;<br>        <span class="hljs-string">&quot; &quot;</span>,    <span class="hljs-comment">// 0</span><br>        <span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// 1</span><br>        <span class="hljs-string">&quot;abc&quot;</span>,  <span class="hljs-comment">// 2</span><br>        <span class="hljs-string">&quot;def&quot;</span>,  <span class="hljs-comment">// 3</span><br>        <span class="hljs-string">&quot;ghi&quot;</span>,  <span class="hljs-comment">// 4</span><br>        <span class="hljs-string">&quot;jkl&quot;</span>,  <span class="hljs-comment">// 5</span><br>        <span class="hljs-string">&quot;mno&quot;</span>,  <span class="hljs-comment">// 6</span><br>        <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>        <span class="hljs-string">&quot;tuv&quot;</span>,  <span class="hljs-comment">// 8</span><br>        <span class="hljs-string">&quot;wxyz&quot;</span>  <span class="hljs-comment">// 9</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> StringBuilder sb;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; ans;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-comment">// 如果输入为空，返回空列表</span><br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始化结果列表和 StringBuilder</span><br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// 开始回溯</span><br>        backtracking(<span class="hljs-number">0</span>, digits);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> startIndex, String digits)</span> &#123;<br>        <span class="hljs-comment">// 如果当前索引等于输入字符串的长度，添加组合到结果列表</span><br>        <span class="hljs-keyword">if</span> (startIndex == digits.length()) &#123;<br>            ans.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获取当前数字对应的字母集</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> digits.charAt(startIndex) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lettermap[tmp].length(); i++) &#123;<br>            <span class="hljs-comment">// 选择一个字母</span><br>            sb.append(lettermap[tmp].charAt(i));<br>            <span class="hljs-comment">// 递归生成下一层的组合</span><br>            backtracking(startIndex + <span class="hljs-number">1</span>, digits);<br>            <span class="hljs-comment">// 撤销上一步选择</span><br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(3^n * 4^m)，其中 n 是对应 3 个字母的数字（如 2, 3, 4, 5, 6, 8）出现的次数，m 是对应 4 个字母的数字（如 7, 9）出现的次数。每次递归调用都会尝试所有可能的字母组合。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是输入字符串的长度。递归调用的深度最多为 n，另外需要 O(n) 的空间来存储临时的组合结果。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>回溯算法在生成组合时，先尝试一个字母，再递归生成下一个字母的组合，最终形成完整的字母组合。</li><li>使用 <code>StringBuilder</code> 来动态构建字符串，并在递归返回时撤销上一步的选择，可以有效减少字符串拼接的开销。</li><li>输入为空字符串时，直接返回空列表，避免不必要的计算。</li></ul><h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了删除链表的倒数第 <code>n</code> 个结点，我们可以使用快慢指针方法。</p><p>使用一个哨兵节点 <code>dummy</code>，指向链表的头节点。这样，即使删除头节点也能方便处理。<br>初始化两个指针 <code>slow</code> 和 <code>fast</code>，都指向哨兵节点。先让快指针 <code>fast</code> 走 <code>n</code> 步。然后同时移动快指针和慢指针，直到快指针到达链表的末尾。此时，慢指针 <code>slow</code> 的下一个节点就是要删除的节点。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个哨兵节点 <code>dummy</code>，并指向链表的头节点 <code>head</code>。</li><li>初始化两个指针 <code>slow</code> 和 <code>fast</code>，都指向哨兵节点 <code>dummy</code>。</li><li>让快指针 <code>fast</code> 先走 <code>n</code> 步。</li><li>继续同时移动 <code>slow</code> 和 <code>fast</code>，直到 <code>fast</code> 的下一个节点为空。</li><li>此时，<code>slow</code> 的下一个节点就是要删除的节点，将 <code>slow</code> 的下一个节点指向其下下个节点。</li><li>返回 <code>dummy</code> 的下一个节点作为新的头节点。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 创建哨兵节点并指向头节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-comment">// 初始化快慢指针</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy, fast = dummy;<br>        <br>        <span class="hljs-comment">// 快指针先走 n 步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 同时移动快慢指针，直到快指针到达链表末尾</span><br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 删除慢指针的下一个节点</span><br>        slow.next = slow.next.next;<br>        <br>        <span class="hljs-comment">// 返回新的头节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(L)，其中 L 是链表的长度。两个指针总共遍历了链表两次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用哨兵节点可以方便处理删除头节点的情况，避免单独处理这种特殊情况。</li><li>快指针先走 <code>n</code> 步，确保了在快指针到达链表末尾时，慢指针正好在需要删除的节点前一个位置。</li><li>如果链表为空或 <code>n</code> 超过链表长度，需要提前进行检查。</li></ul><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">https://leetcode.cn/problems/valid-parentheses/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 <code>s</code>，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了判断一个字符串中的括号是否有效，我们可以使用栈来辅助匹配括号。具体步骤如下：</p><ol><li>遍历字符串 <code>s</code> 中的每一个字符：<ul><li>如果是左括号，将其压入栈中。</li><li>如果是右括号，检查栈是否为空。如果栈为空，说明没有匹配的左括号，字符串无效。否则，弹出栈顶元素，并检查是否与当前右括号匹配。</li></ul></li><li>遍历完成后，如果栈为空，说明所有的左括号都匹配了相应的右括号，字符串有效。否则，字符串无效。</li></ol><h3 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个栈来存储左括号。</li><li>遍历字符串 <code>s</code>，对于每个字符：<ul><li>如果是左括号，将其压入栈中。</li><li>如果是右括号，检查栈是否为空。如果为空，返回 <code>false</code>。否则，弹出栈顶元素，并检查是否与当前右括号匹配。如果不匹配，返回 <code>false</code>。</li></ul></li><li>遍历完成后，检查栈是否为空。如果为空，返回 <code>true</code>，否则返回 <code>false</code>。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 栈用于存储左括号</span><br>        <span class="hljs-type">char</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[s.length()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历字符串中的每个字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-comment">// 如果是左括号，压入栈中</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                stack[top++] = c;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果是右括号，检查栈是否为空或栈顶是否匹配</span><br>                <span class="hljs-keyword">if</span> (top == <span class="hljs-number">0</span> || stack[top - <span class="hljs-number">1</span>] != getMatchingLeftBracket(c)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                top--; <span class="hljs-comment">// 匹配成功，弹出栈顶元素</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 栈为空，说明所有括号匹配成功</span><br>        <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回对应的左括号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getMatchingLeftBracket</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是字符串的长度。我们只遍历一次字符串。</li><li><strong>空间复杂度</strong>: O(n)，其中 n 是字符串的长度。最坏情况下栈中会存储所有的左括号。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>栈顶元素和当前右括号匹配时，弹出栈顶元素。</li><li>如果栈为空或栈顶元素不匹配，直接返回 <code>false</code>。</li><li>遍历结束后，检查栈是否为空，以判断所有的括号是否都匹配成功。</li></ul><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">https://leetcode.cn/problems/merge-two-sorted-lists/description/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了合并两个升序链表，我们可以使用双指针方法，同时遍历两个链表，将较小的节点依次加入到新的链表中。为了简化操作，我们可以使用一个哨兵节点来指向新链表的头节点。</p><h3 id="详细步骤-3"><a href="#详细步骤-3" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>创建一个哨兵节点 <code>dummy</code>，并初始化一个指针 <code>pre</code> 指向哨兵节点。</li><li>同时遍历两个链表 <code>list1</code> 和 <code>list2</code>：<ul><li>比较当前节点的值，将较小的节点加入到新链表中，并移动指针到下一个节点。</li><li>更新 <code>pre</code> 指向新链表的最新节点。</li></ul></li><li>当其中一个链表遍历完后，将另一个链表的剩余部分直接接到新链表的末尾。</li><li>返回哨兵节点的下一个节点，即新的头节点。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-comment">// 创建哨兵节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br><br>        <span class="hljs-comment">// 同时遍历两个链表</span><br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>                pre.next = list1;<br>                list1 = list1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre.next = list2;<br>                list2 = list2.next;<br>            &#125;<br>            pre = pre.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 将剩余的链表部分接到新链表的末尾</span><br>        pre.next = (list1 == <span class="hljs-literal">null</span>) ? list2 : list1;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n + m)，其中 n 和 m 分别是两个链表的长度。我们需要遍历两个链表中的每个节点。</li><li><strong>空间复杂度</strong>: O(1)，我们只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用哨兵节点可以简化操作，避免处理头节点为空的特殊情况。</li><li>在比较节点值时，需要确保 <code>pre</code> 指向的是新链表的最新节点，并更新 <code>pre</code>。</li><li>在其中一个链表遍历完后，直接将另一个链表的剩余部分接到新链表末尾即可。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-2</title>
    <link href="/2024/07/28/hot100-2/"/>
    <url>/2024/07/28/hot100-2/</url>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">https://leetcode.cn/problems/longest-palindromic-substring/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题要求找到字符串中的最长回文子串。我们可以使用中心扩展法来解决这个问题。对于每个字符，我们尝试将其作为中心，向左右两侧扩展，检查扩展后形成的子串是否为回文。需要注意的是，回文子串的长度可以是奇数也可以是偶数，因此我们需要分别处理这两种情况。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化两个变量 len 和 index 分别记录最长回文子串的长度和起始位置。</li><li>遍历字符串中的每个字符，以当前字符为中心向左右扩展，检查形成的子串是否为回文。</li><li>对于每个字符，分别处理回文子串长度为奇数和偶数的情况。</li><li>在扩展过程中，如果发现更长的回文子串，更新 len 和 index。</li><li>最后，根据 index 和 len 返回最长回文子串。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长回文子串的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长回文子串的起始位置</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 处理奇数长度的回文子串</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>, right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最长回文子串的长度和起始位置</span><br>            <span class="hljs-keyword">if</span> (len &lt; right - left - <span class="hljs-number">1</span>) &#123;<br>                index = left + <span class="hljs-number">1</span>;<br>                len = right - left - <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 处理偶数长度的回文子串</span><br>            left = i;<br>            right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最长回文子串的长度和起始位置</span><br>            <span class="hljs-keyword">if</span> (len &lt; right - left - <span class="hljs-number">1</span>) &#123;<br>                index = left + <span class="hljs-number">1</span>;<br>                len = right - left - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回最长回文子串</span><br>        <span class="hljs-keyword">return</span> s.substring(index, len + index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n^2)，其中 n 是字符串的长度。中心扩展法的每次扩展操作在最坏情况下需要遍历整个字符串，因此总时间复杂度为 O(n^2)。</li><li><strong>空间复杂度</strong>：O(1)，我们只使用了常数空间来存储变量。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要分别处理回文子串长度为奇数和偶数的情况。</li><li>确保在每次扩展后更新最长回文子串的长度和起始位置。</li><li>在进行字符串截取时，注意索引的正确计算，避免越界。</li></ul><h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h1><p><a href="https://leetcode.cn/problems/regular-expression-matching/description/">https://leetcode.cn/problems/regular-expression-matching/description/</a></p><h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><p><a href="https://leetcode.cn/problems/container-with-most-water/description/">https://leetcode.cn/problems/container-with-most-water/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题的目标是找到两个线段，使它们与 x 轴形成的容器能够容纳最多的水。我们可以使用双指针方法，从两端向中间靠拢，以此找到最大面积。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化两个指针 <code>left</code> 和 <code>right</code> 分别指向数组的左右两端，以及变量 <code>ans</code> 来存储最大面积。</li><li>使用一个 <code>while</code> 循环，当 <code>left</code> 小于 <code>right</code> 时，进行以下操作：<ul><li>计算当前容器的面积，面积的高度是 <code>height[left]</code> 和 <code>height[right]</code> 中的较小值，宽度是 <code>right - left</code>。</li><li>更新最大面积 <code>ans</code>。</li><li>如果 <code>height[left]</code> 小于 <code>height[right]</code>，移动左指针 <code>left</code> 向右一步，否则移动右指针 <code>right</code> 向左一步。</li></ul></li><li>返回 <code>ans</code> 作为结果。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 初始化最大面积为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 使用双指针，一头一尾</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>; <br>        <br>        <span class="hljs-comment">// 双指针向中间移动</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 计算当前容器的面积，并更新最大面积</span><br>            ans = Math.max((right - left) * Math.min(height[left], height[right]), ans);<br>            <br>            <span class="hljs-comment">// 移动较矮的那条边的指针</span><br>            <span class="hljs-keyword">if</span> (height[left] &gt; height[right]) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n)，其中 n 是数组的长度。每个元素最多被访问一次。</li><li><strong>空间复杂度</strong>: O(1)，只使用了常数级别的额外空间。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>双指针方法利用了贪心策略：总是尝试通过移动较矮的边来找到更大的容器。</li><li>如果两个指针指向的高度相等，任意移动一个指针都可以。</li></ul><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><p><a href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了找到所有和为0的三元组，我们可以使用排序和双指针方法。具体步骤如下：</p><ol><li>首先对数组进行排序，这样我们可以使用双指针来查找三元组。</li><li>遍历排序后的数组，对于每个元素 <code>nums[i]</code>，使用双指针 <code>left</code> 和 <code>right</code> 在其后的子数组中寻找两个数，使它们的和为 <code>-nums[i]</code>。</li><li>为了避免重复的三元组，我们需要跳过相同的元素。</li></ol><h3 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>对数组进行排序。</li><li>初始化结果列表 <code>ans</code>。</li><li>遍历数组，对于每个元素 <code>nums[i]</code>：<ul><li>如果当前元素与前一个元素相同，跳过，避免重复的三元组。</li><li>使用双指针 <code>left</code> 和 <code>right</code> 分别指向 <code>i+1</code> 和数组末尾。</li><li>计算三数之和 <code>sum = nums[i] + nums[left] + nums[right]</code>。</li><li>如果 <code>sum == 0</code>，将三元组加入结果列表，并移动指针，跳过重复元素。</li><li>如果 <code>sum &lt; 0</code>，移动左指针 <code>left</code> 向右一步。</li><li>如果 <code>sum &gt; 0</code>，移动右指针 <code>right</code> 向左一步。</li></ul></li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 初始化结果列表</span><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 对数组进行排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 跳过重复元素</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 初始化双指针</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 找到一个三元组</span><br>                    ans.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 跳过重复元素</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;<br>                        left++;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-comment">// 移动指针</span><br>                    left++;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>: O(n^2)，其中 n 是数组的长度。排序的时间复杂度为 O(n log n)，遍历数组的时间复杂度为 O(n^2)。</li><li><strong>空间复杂度</strong>: O(1)，不考虑结果列表的空间，使用了常数级别的额外空间。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>为了避免重复的三元组，遍历数组时需要跳过相同的元素。</li><li>在寻找三元组的过程中，双指针也需要跳过重复的元素。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100-1</title>
    <link href="/2024/07/26/hot100-1/"/>
    <url>/2024/07/26/hot100-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/description/">https://leetcode.cn/problems/two-sum/description/</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>使用哈希表存储数组中每个元素的值及其对应的索引。</li><li>在遍历数组的过程中，计算目标值与当前元素的差值。</li><li>检查哈希表中是否存在这个差值。<ul><li>如果存在，则找到了两个数，返回它们的索引。</li><li>如果不存在，将当前元素及其索引存入哈希表。</li></ul></li></ol><p>这种方法只需遍历数组一次，时间复杂度为 O(n)，空间复杂度也为 O(n)。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 创建一个哈希表来存储数值和对应的索引</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> target - nums[i];<br>            <br>            <span class="hljs-comment">// 如果哈希表中存在目标值减去当前值的结果，则返回对应的索引</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(tmp)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(tmp), i&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则，将当前值和索引放入哈希表</span><br>                map.put(nums[i], i);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果没有找到合适的数对，返回空数组（可以根据需求修改）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p><strong>时间复杂度</strong>：O(n)</p><ul><li>因为只需要遍历数组一次，每次查找哈希表的复杂度为 O(1)，总时间复杂度为 O(n)。</li></ul></li><li><p><strong>空间复杂度</strong>：O(n)</p><ul><li>在最坏情况下，哈希表中存储了 n 个元素，因此空间复杂度为 O(n)。</li></ul></li></ul><br><br><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><p><a href="https://leetcode.cn/problems/add-two-numbers/description/">https://leetcode.cn/problems/add-two-numbers/description/</a></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>创建一个虚拟头节点 <code>dummy</code> 以便于处理结果链表。</li><li>使用指针 <code>pre</code> 指向当前处理的节点，初始化为 <code>dummy</code>。</li><li>初始化进位 <code>carry</code> 为 0。</li><li>遍历两个链表，直到都为空：<ul><li>取出当前节点的值 <code>x</code> 和 <code>y</code>，如果链表已经结束则为 0。</li><li>计算当前位的和 <code>sum = x + y + carry</code>。</li><li>更新进位 <code>carry = sum / 10</code>。</li><li>当前位的值为 <code>sum % 10</code>。</li><li>将当前节点的结果添加到结果链表中。</li><li>移动指针到下一个节点。</li></ul></li><li>最后，如果还有进位，添加到结果链表中。</li><li>返回结果链表的下一个节点，即 <code>dummy.next</code>。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (l1 != <span class="hljs-literal">null</span>) ? l1.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (l2 != <span class="hljs-literal">null</span>) ? l2.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y + carry;<br><br>            carry = sum / <span class="hljs-number">10</span>;<br>            sum = sum % <span class="hljs-number">10</span>;<br><br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            pre = pre.next;<br><br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) l2 = l2.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理最高位的进位</span><br>        <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是较长链表的长度。需要遍历一次每个节点。</li><li><strong>空间复杂度</strong>：O(n)，用于存储结果链表。</li></ul><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题可以使用滑动窗口的技巧来解决。我们维护一个窗口，并使用两个指针（left 和 right）来标记窗口的左右边界。同时使用一个哈希集合（Set）来存储当前窗口内的字符。随着右指针的移动，我们检查字符是否重复，如果重复则移动左指针以缩小窗口，直到窗口内没有重复字符为止。在这个过程中，我们记录并更新最长的无重复字符子串的长度。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>初始化一个哈希集合（Set）用于存储当前窗口内的字符。</li><li>初始化两个指针 left 和 right，均指向字符串的起始位置。</li><li>初始化一个变量 ans 来记录最长无重复字符子串的长度。</li><li>遍历字符串，移动右指针，并检查当前字符是否在哈希集合中。</li><li>如果当前字符不在集合中，则将其加入集合，并继续移动右指针。</li><li>如果当前字符在集合中，则更新最长长度，并移动左指针，直到窗口内不再包含重复字符。</li><li>重复步骤4-6，直到右指针遍历完整个字符串。</li><li>返回 ans 作为结果。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 使用哈希集合来存储当前窗口内的字符</span><br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 滑动窗口的左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录最长无重复字符子串的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>            <span class="hljs-type">Character</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-keyword">if</span>(set.contains(c))&#123;<br>                <span class="hljs-comment">// 更新最长长度</span><br>                ans = Math.max(ans, right - left);<br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-comment">// 移动左指针，直到窗口内不再包含重复字符</span><br>                    <span class="hljs-keyword">if</span>(s.charAt(left) == c)&#123;<br>                        left++;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    set.remove(s.charAt(left));<br>                    left++;<br>                &#125;<br>            &#125;<br>            set.add(c);<br>            right++;<br>        &#125;<br>        <span class="hljs-comment">// 最后一次更新最长长度</span><br>        ans = Math.max(ans, right - left);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是字符串的长度。每个字符在滑动窗口中最多被访问两次（一次通过右指针，一次通过左指针）。</li><li><strong>空间复杂度</strong>：O(min(n, m))，其中 n 是字符串的长度，m 是字符集的大小。在最坏情况下，字符串中的所有字符都不同，因此哈希集合需要存储所有字符。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>需要特别注意处理边界情况，例如空字符串的输入。</li><li>在计算最长长度时，要确保在循环结束后再进行一次更新，以处理窗口移动到字符串末尾的情况。</li></ul><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h1><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">https://leetcode.cn/problems/median-of-two-sorted-arrays/description/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。算法的时间复杂度应该为 O(log (m+n))。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题要求时间复杂度为 O(log (m+n))，提示我们可以使用二分查找的方法。我们通过在较短的数组上进行二分查找，找到一个划分，使得左半部分和右半部分的元素个数相等，并且左半部分的最大值小于等于右半部分的最小值。根据这个划分点，我们可以计算出中位数。</p><h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>确保 nums1 是较短的数组，以简化后续逻辑。</li><li>初始化两个指针 left 和 right 分别指向 nums1 的左右边界。</li><li>使用二分查找，计算 nums1 和 nums2 的划分点 m1 和 m2。</li><li>检查划分是否符合条件：nums1[m1] &gt;&#x3D; nums2[m2 - 1] 且 nums1[m1 - 1] &lt;&#x3D; nums2[m2]。</li><li>如果条件不满足，根据情况调整 left 或 right 指针，缩小搜索范围。</li><li>计算最终的中位数，根据总长度的奇偶性返回结果。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-comment">// 确保 nums1 是较短的数组</span><br>        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length) &#123;<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 二分查找的中点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-comment">// 计算 nums2 的划分点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - m1;<br><br>            <span class="hljs-comment">// nums1 的划分点过小，增大 left</span><br>            <span class="hljs-keyword">if</span> (m1 &lt; m &amp;&amp; nums1[m1] &lt; nums2[m2 - <span class="hljs-number">1</span>]) &#123;<br>                left = m1 + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// nums1 的划分点过大，减小 right</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m1 &gt; <span class="hljs-number">0</span> &amp;&amp; nums1[m1 - <span class="hljs-number">1</span>] &gt; nums2[m2]) &#123;<br>                right = m1 - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 找到合适的划分点</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> maxleft;<br>                <span class="hljs-comment">// 处理边界情况</span><br>                <span class="hljs-keyword">if</span> (m1 == <span class="hljs-number">0</span>) &#123;<br>                    maxleft = nums2[m2 - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == <span class="hljs-number">0</span>) &#123;<br>                    maxleft = nums1[m1 - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    maxleft = Math.max(nums1[m1 - <span class="hljs-number">1</span>], nums2[m2 - <span class="hljs-number">1</span>]);<br>                &#125;<br><br>                <span class="hljs-comment">// 总长度为奇数，中位数为 maxleft</span><br>                <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> maxleft;<br>                &#125;<br><br>                <span class="hljs-type">int</span> minright;<br>                <span class="hljs-comment">// 处理边界情况</span><br>                <span class="hljs-keyword">if</span> (m1 == m) &#123;<br>                    minright = nums2[m2];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == n) &#123;<br>                    minright = nums1[m1];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    minright = Math.min(nums1[m1], nums2[m2]);<br>                &#125;<br><br>                <span class="hljs-comment">// 总长度为偶数，中位数为 maxleft 和 minright 的平均值</span><br>                <span class="hljs-keyword">return</span> (maxleft + minright) / <span class="hljs-number">2.0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(log(min(m, n)))，其中 m 和 n 分别是两个数组的长度。因为我们在较短的数组上进行二分查找。</li><li><strong>空间复杂度</strong>：O(1)，我们只使用了常数空间来存储变量。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保 nums1 是较短的数组，可以简化边界条件的处理。</li><li>处理边界情况时，确保划分点在数组范围内，避免数组越界。</li><li>总长度为奇数和偶数的情况需要分别处理。</li></ul><h4 id="为什么从较短的数组开始"><a href="#为什么从较短的数组开始" class="headerlink" title="为什么从较短的数组开始"></a>为什么从较短的数组开始</h4><p>减少边界情况：当我们在较短的数组上进行二分查找时，我们只需要考虑较短数组的长度，这样划分点的计算和调整会更加简单。如果我们在较长的数组上进行二分查找，划分点可能会落在较长数组的边界附近，增加处理复杂性。</p><p>避免数组越界：在二分查找过程中，我们需要根据划分点计算两个数组的左半部分和右半部分。如果我们在较短的数组上进行二分查找，更容易确保划分点在数组范围内，避免数组越界。</p><p>优化性能：在较短的数组上进行二分查找，能够更快地收敛到正确的划分点。因为较短数组的长度更小，二分查找的迭代次数也会相应减少，从而提高性能。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>themes</title>
    <link href="/2024/07/26/themes/"/>
    <url>/2024/07/26/themes/</url>
    
    <content type="html"><![CDATA[<h1 id="fluid"><a href="#fluid" class="headerlink" title="fluid"></a>fluid</h1><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p><img src="/2024/07/26/themes/fluid.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>themes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learn_markdown</title>
    <link href="/2024/07/23/learn-markdown/"/>
    <url>/2024/07/23/learn-markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>使用#的数量定义标题的级别，#后面与标题之间有一个空格</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><h6 id="6"><a href="#6" class="headerlink" title="6"></a>6</h6><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>段落与段落之间用空白行分割</p><p>我看见他戴着黑布小帽，穿着黑布大马褂，深青布棉袍，蹒跚地走到铁道边，慢慢探身下去，尚不大难。可是他穿过铁道，要爬上那边月台，就不容易了。他用两手攀着上面，两脚再向上缩；他肥胖的身子向左微倾，显出努力的样子。这时我看见他的背影，我的泪很快地流下来了。我赶紧拭干了泪，怕他看见，也怕别人看见。我再向外看时，他已抱了朱红的橘子望回走了。过铁道时，他先将橘子散放在地上，自己慢慢爬下，再抱起橘子走。到这边时，我赶紧去搀他。他和我走到车上，将橘子一股脑儿放在我的皮大衣上。于是扑扑衣上的泥土，心里很轻松似的，过一会说，“我走了；到那边来信！”我望着他走出去。他走了几步，回过头看见我，说，“进去吧，里边没人。”等他的背影混入来来往往的人里，再找不着了，我便进来坐下，我的眼泪又来了。 — 摘自朱自清的《背影》</p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>静夜思<br>李白<br>床前明月光，疑是地上霜。<br>举头望明月，低头思故乡。</p><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>你__好__   <strong>你好</strong><br><strong>hello</strong> hello<br>你也<strong>好</strong></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p><em>斜体</em><br>_斜体<br>xie<em>斜体</em>ti</p><h3 id="粗体加斜体"><a href="#粗体加斜体" class="headerlink" title="粗体加斜体"></a>粗体加斜体</h3><p><em><strong>粗体斜体</strong></em></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>sssssssss<br>ssssssss<br>ssssss  </p></blockquote><blockquote><p>sdsdsdsd</p></blockquote><p>段落 + 引用</p><blockquote><p>sdsdsdsd</p><p>sdsdsdsd</p></blockquote><p>嵌套块引用</p><blockquote><p>ss</p><blockquote><p>ss</p><blockquote><p>ss</p><blockquote><p>ss</p></blockquote></blockquote></blockquote><p>s</p></blockquote><p>引用 + 其他</p><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h1 id="images"><a href="#images" class="headerlink" title="images"></a>images</h1><p>图片放置格式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[]</span>(png.jpg)<br></code></pre></td></tr></table></figure><p><img src="/2024/07/23/learn-markdown/pdx1.jpg"></p><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="hljs-variable">$a</span><span class="hljs-keyword">^2</span><span class="language-xml"> + b</span><span class="hljs-keyword">^2</span><span class="language-xml"> = c</span><span class="hljs-keyword">^2</span><span class="language-xml">$</span><br></code></pre></td></tr></table></figure><p>$a^2 + b^2 &#x3D; c^2$</p><h2 id="块级公式"><a href="#块级公式" class="headerlink" title="块级公式"></a>块级公式</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span> = c^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>a^2 + b^2 &#x3D; c^2<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
